[
  {
    "objectID": "renabap.html",
    "href": "renabap.html",
    "title": "4 RENABAP",
    "section": "",
    "text": "4.1 Resumen ejecutivo\nEste an치lisis demuestra que el uso de datos de huellas de edificaciones mejora significativamente tanto la precisi칩n como la comprehensividad del mapeo de riesgo en asentamientos informales cuando se compara con la interpolaci칩n areal y los datos del RENABAP. Este enfoque basado en edificaciones no solo proporciona estimaciones m치s precisas y actualizadas que los m칠todos tradicionales de interpolaci칩n areal, sino que tambi칠n demuestra la necesidad urgente de actualizar los registros oficiales de barrios populares, representando una herramienta esencial para comprender la verdadera magnitud de la poblaci칩n en riesgo y para la planificaci칩n efectiva de pol칤ticas p칰blicas de diversa naturaleza.\nLos datos de huellas de edificaciones nos permiten realizar evaluaciones mucho m치s precisas de la exposici칩n en barrios populares y revelan una subestimaci칩n cr칤tica en los datos oficiales del RENABAP, identificando aproximadamente 41.575 edificaciones faltantes que representan entre 137.000 y 229.000 personas no contabilizadas. La comparaci칩n metodol칩gica demuestra que nuestro enfoque aporta un mayor n칰mero total de poblaci칩n expuesta (aproximadamente el doble de edificaciones que los datos oficiales) pero una menor proporci칩n de exposici칩n relativa (23,5% vs 26,3%), lo que demuestra que la interpolaci칩n areal sobrestima la exposici칩n al asumir distribuci칩n uniforme de la poblaci칩n, mientras que nuestro m칠todo m치s preciso es m치s confiable para la evaluaci칩n de riesgos.\nEn los barrios populares de La Plata se identifican 17.014 edificaciones expuestas a peligro de inundaci칩n ante el escenario de PMP, lo que representa el 23,5% del total de edificaciones en barrios populares. De estas, 6.112 edificaciones se encuentran en zonas de peligro alto y 10.902 en zonas de peligro medio. Los barrios con mayor exposici칩n incluyen: Villa Montoro con 669 edificaciones expuestas a peligro alto (21,7% del barrio), seguido por La Esperanza con 440 edificaciones (16,3%), Las Palmeras con 417 (33,7%), Toba con 335 (67,7%), y La Isla con 320 edificaciones (96,4%). A nivel de cuencas hidrogr치ficas, Cuenca Arroyo del Gato concentra la mayor exposici칩n con 7.943 edificaciones expuestas (2.662 a peligro alto y 5.281 a peligro medio), seguida por Cuenca A춿 Maldonado con 3.316 edificaciones (1.000 alta, 2.316 media) y Cuenca Arroyo Mart칤n-Carnaval con 1.096 edificaciones (368 alta, 728 media).\nEl an치lisis comparativo de diferentes per칤odos de retorno revela que la elecci칩n del per칤odo genera diferencias significativas en las estimaciones de exposici칩n, siendo crucial para determinar qu칠 치reas priorizar para la reubicaci칩n de residentes en asentamientos informales. La exposici칩n calculada con PMP puede ser hasta 13,0 veces mayor que con un per칤odo de retorno de 25 a침os, lo que tiene consecuencias significativas para la evaluaci칩n de pol칤ticas p칰blicas como la reubicaci칩n de poblaciones.",
    "crumbs": [
      "<span class='chapter-number'>4</span> <span class='chapter-title'>RENABAP</span>"
    ]
  },
  {
    "objectID": "renabap.html#resumen-ejecutivo",
    "href": "renabap.html#resumen-ejecutivo",
    "title": "4 RENABAP",
    "section": "",
    "text": "游닌 Descargar los datos de exposici칩n de edificios a nivel de barrio\n游닌 Descargar los datos de exposici칩n de edificios a nivel de cuenca y eje",
    "crumbs": [
      "<span class='chapter-number'>4</span> <span class='chapter-title'>RENABAP</span>"
    ]
  },
  {
    "objectID": "renabap.html#objetivos",
    "href": "renabap.html#objetivos",
    "title": "4 RENABAP",
    "section": "4.2 Objetivos",
    "text": "4.2 Objetivos\nEste proyecto se propone tres objetivos principales:\n\nIdentificar metodolog칤as m치s precisas para evaluar la poblaci칩n expuesta en barrios populares seg칰n lo determina el RENABAP Se procura desarrollar y aplicar t칠cnicas de an치lisis espacial que superen las limitaciones de la interpolaci칩n areal tradicional, utilizando datos de huellas de edificaciones para obtener estimaciones m치s precisas de la exposici칩n ante el peligro de inundaci칩n en los barrios populares, y demostrar las limitaciones significativas de los datos oficiales del RENABAP en relaci칩n al n칰mero de viviendas y poblaci칩n.\nAportar y precisar el mapeo del riesgo h칤drico en el Partido de La Plata Se pretende mejorar la comprensi칩n de la distribuci칩n espacial del riesgo de inundaci칩n mediante el an치lisis de la exposici칩n de viviendas vulnerables que forman parte de los barrios populares registrados por el RENABAP, proporcionando informaci칩n detallada para la toma de decisiones a nivel municipal y la planificaci칩n de pol칤ticas de reducci칩n de riesgo.\nPoner en cuesti칩n las recurrencias utilizadas para el c치lculo del riesgo por inundaciones, en funci칩n de la pol칤tica p칰blica a implementar Evaluar cr칤ticamente los per칤odos de retorno utilizados en los modelos de peligrosidad para la construcci칩n de los mapas de riesgo y examinar la importancia de la precisi칩n de los datos considerados en funci칩n de la pol칤tica p칰blica a implementar.\n\n\n\nMostrar c칩digo\nimport matplotlib.pyplot as plt\n\nfrom io import StringIO\nfrom shapely.geometry import box\nimport geopandas as gpd\nimport requests\nimport os\n\nimport itables\nfrom itables import show\nfrom IPython.display import HTML, display\n\nfrom matplotlib_map_utils import north_arrow, scale_bar, ScaleBar\n\nfrom matplotlib.patches import Patch\n\n\nfrom shapely.ops import unary_union\nimport contextily as cx\n\n# Global settings for international number formatting\nimport locale\nimport pandas as pd\nimport numpy as np\n\n# Set locale for international number formatting (period for thousands, comma for decimal)\ntry:\n    locale.setlocale(locale.LC_ALL, 'es_AR.UTF-8')\nexcept locale.Error:\n    try:\n        locale.setlocale(locale.LC_ALL, 'es_ES.UTF-8')\n    except locale.Error:\n        locale.setlocale(locale.LC_ALL, '')\n\n# Set pandas options for international formatting\npd.set_option('display.float_format', lambda x: f'{x:,.1f}'.replace(',', '.').replace('.', ',', 1))\n\n# Helper function to format numbers with international formatting (periods for thousands, commas for decimals)\ndef format_number(num, decimals=None):\n    if decimals is None:\n        # Integer formatting - periods for thousands separators\n        return f\"{num:,}\".replace(\",\", \".\")\n    else:\n        # Decimal formatting - periods for thousands, commas for decimals\n        formatted = f\"{num:,.{decimals}f}\"\n        # Split by decimal point\n        parts = formatted.split(\".\")\n        if len(parts) == 2:\n            # Add periods for thousands in integer part, keep comma for decimal\n            integer_part = parts[0].replace(\",\", \".\")\n            return f\"{integer_part},{parts[1]}\"\n        else:\n            # No decimal part, just add periods for thousands\n            return parts[0].replace(\",\", \".\")\n\nfrom utils.utils import (\n    add_scale_bar_and_north_arrow,\n    add_basemap,\n    add_boundary_outline,\n    create_consistent_map,\n    wfs_to_gdf,\n    fetch_buildings,\n)\n\nScaleBar.set_size(size=\"md\")\n\n# Configure Argentine Spanish for itables\ntry:\n    spanish_url = \"https://cdn.datatables.net/plug-ins/2.3.3/i18n/es-AR.json\"\n    response = requests.get(spanish_url)\n    response.raise_for_status()\n    spanish_config = response.json()\n    itables.options.language = spanish_config\nexcept Exception:\n    pass\n\n# Configure smaller font size for all itables\ncss = \"\"\"\n.dt-container {\n  font-size: small;\n}\n\"\"\"\ndisplay(HTML(f\"&lt;style&gt;{css}&lt;/style&gt;\"))\n\n\n# Helper function to round numeric columns for display\ndef round_numeric_columns(df, decimals=0):\n    \"\"\"Round all numeric columns in a DataFrame to specified decimal places.\"\"\"\n    df_display = df.copy()\n    numeric_columns = df_display.select_dtypes(include=[np.number]).columns\n    df_display[numeric_columns] = df_display[numeric_columns].round(decimals)\n    return df_display\n\ndef add_scale_bar_and_north_arrow(\n    ax, location=\"upper right\", scale_color=\"black\", arrow_color=\"black\", length=None\n):\n    \"\"\"Add a scale bar and north arrow to the map using matplotlib_map_utils.\"\"\"\n    # Add scale bar using matplotlib_map_utils ScaleBar class with ticks style\n    scale_bar(\n        ax=ax,\n        location=\"upper left\",\n        style=\"ticks\",\n        bar={\n            \"projection\": \"EPSG:3857\",\n            \"tickcolors\": scale_color,\n            \"basecolors\": scale_color,\n            \"minor_type\": \"none\",\n            \"length\": length,\n        },\n        labels={\"style\": \"first_last\"},\n    )\n\n    # Add north arrow using matplotlib_map_utils\n    north_arrow(\n        ax,\n        location=location,\n        scale=0.3,  # Small size\n        rotation={\"degrees\": 0},\n        base={\"facecolor\": \"none\", \"edgecolor\": arrow_color, \"linewidth\": 1},\n        fancy=True,\n        shadow=True,\n        label=False,  # Hide the \"N\" text\n    )\n\ndef setup_base_map(\n    use_crs, figsize=None, bounds=None, boundary_gdf=None, padding_x=None, padding_y=None\n):\n    \"\"\"Create figure and set up basic map boundaries with padding.\"\"\"\n    if figsize is None:\n        figsize = DEFAULT_FIGSIZE\n    if padding_x is None:\n        padding_x = MAP_PADDING\n    if padding_y is None:\n        padding_y = MAP_PADDING\n\n    if bounds is None and boundary_gdf is not None:\n        bounds = boundary_gdf.total_bounds\n\n    # Convert bounds to Web Mercator for basemap compatibility\n    if bounds is not None:\n        # Create a temporary GeoDataFrame with the bounds to reproject\n        temp_bounds = gpd.GeoDataFrame(\n            geometry=[box(bounds[0], bounds[1], bounds[2], bounds[3])], crs=use_crs\n        )\n        bounds_3857 = temp_bounds.to_crs(WEB_MERCATOR_CRS).total_bounds\n    else:\n        bounds_3857 = bounds\n\n    fig, ax = plt.subplots(figsize=figsize)\n    ax.set_xlim(bounds_3857[0] - padding_x, bounds_3857[2] + padding_x)\n    ax.set_ylim(bounds_3857[1] - padding_y, bounds_3857[3] + padding_y)\n    return fig, ax\n\ndef create_consistent_map(title, crs, boundary_gdf=None, bounds=None, attribution=None, scalebar_length=None):\n    \"\"\"Create a map with consistent styling and basemap.\"\"\"\n    fig, ax = setup_base_map(crs, bounds=bounds, boundary_gdf=boundary_gdf)\n\n    add_basemap(ax, attribution=attribution)\n\n    add_scale_bar_and_north_arrow(ax, length=scalebar_length)\n\n    add_boundary_outline(ax, boundary_gdf)\n\n    ax.set_title(title, fontsize=16, fontweight=\"bold\", pad=20)\n\n    ax.set_axis_off()\n\n    return fig, ax\n\n\n\n# =============================================================================\n# CONSTANTES Y CONFIGURACI칍N\n# =============================================================================\n\nUSE_CRS = \"EPSG:5349\"  # POSGAR 2007 / Argentina 4\nWEB_MERCATOR_CRS = \"EPSG:3857\"  # visualization\nWGS84_CRS = \"EPSG:4326\"  # for API calls\n\nBASE_PATH = \"/home/nissim/Documents/dev/fulbright/ciut-riesgo\"\nDATA_PATH = f\"{BASE_PATH}/notebooks/data\"\nPELIGRO_PATH = f\"{DATA_PATH}/la_plata_pelig_2023_datos_originales.geojson\"\nPARTIDOS_PATH = f\"{DATA_PATH}/pba_partidos.geojson\"\nCUENCAS_PATH = f\"{BASE_PATH}/notebooks/cuencas_buenos_aires.geojson\"\nBUILDINGS_PATH = f\"{BASE_PATH}/notebooks/buildings_filtered.parquet\"\n\nRENABAP_URL = (\n    \"https://www.argentina.gob.ar/sites/default/files/renabap-2023-12-06.geojson\"\n)\nPARTIDOS_WFS_URL = \"https://geo.arba.gov.ar/geoserver/idera/wfs\"\nCUENCAS_API_URL = \"https://services1.arcgis.com/atxllciEI8CHWvwW/ArcGIS/rest/services/Cuencas_BuenosAires_2023/FeatureServer/0/query\"\n\n\n# Basic visualization settings (only for repeated values)\nDEFAULT_FIGSIZE = (12, 10)\nMAP_PADDING = 500\nPLASMA_CMAP = plt.cm.plasma\n\n# Color schemes for visualization\nPELIGROSIDAD_COLORS = {\n    \"alta\": PLASMA_CMAP(0.5),\n    \"media\": PLASMA_CMAP(0.8),\n}\n\n\nPELIGROSIDAD_LEGEND = [\n    Patch(facecolor=color, label=label) for label, color in PELIGROSIDAD_COLORS.items()\n]\n\n\n# Eje mapping for watershed analysis\nEJE_MAPPING = {\n    \"noreste\": [\"Area de Ba침ados\", \"Cuenca Arroyo Rodriguez-Don Carlos\"],\n    \"noroeste\": [\"Cuenca Arroyo Mart칤n-Carnaval\", \"Cuenca Arroyo Pereyra\"],\n    \"central\": [\"Cuenca Arroyo del Gato\"],\n    \"sudoeste\": [\"Cuenca A춿 Maldonado\", \"Cuenca R칤o Samboromb칩n\"],\n    \"sudeste\": [\"Cuenca Arroyo El Pescado\"],\n}\n\n\n\n\n\n# =============================================================================\n# DATA LOADING AND PREPROCESSING\n# =============================================================================\n\nresponse = requests.get(RENABAP_URL)\nrenabap = gpd.read_file(StringIO(response.text))\nrenabap_pba = renabap[renabap[\"provincia\"] == \"Buenos Aires\"]\nrenabap_pba = renabap_pba.to_crs(USE_CRS)\n\n\nif os.path.exists(PARTIDOS_PATH):\n    partidos = gpd.read_file(PARTIDOS_PATH)\nelse:\n    partidos = wfs_to_gdf(\n        wfs_url=PARTIDOS_WFS_URL,\n        layer_name=\"idera:Departamento\",\n        srs=\"EPSG:5347\",\n    )\n\n    partidos.to_file(PARTIDOS_PATH, driver=\"GeoJSON\")\n\npartidos = partidos.to_crs(USE_CRS)\nla_plata = partidos[partidos[\"fna\"] == \"Partido de La Plata\"]\n\n# Obtener la geometr칤a principal\nmain_geom = la_plata.geometry.iloc[0]\n\n# Si es un MultiPolygon, mantener solo el pol칤gono m치s grande (el partido principal)\n# Esto elimina la peque침a isla que aparece en los datos\nif main_geom.geom_type == \"MultiPolygon\":\n    # Obtener todos los pol칤gonos y mantener el que tenga mayor 치rea\n    largest_polygon = max(main_geom.geoms, key=lambda p: p.area)\n    la_plata = la_plata.copy()  # Create a copy to avoid SettingWithCopyWarning\n    la_plata.loc[la_plata.index[0], \"geometry\"] = largest_polygon\n\nla_plata_bbox = la_plata.geometry.iloc[0]\n\n\npeligro = gpd.read_file(PELIGRO_PATH)\npeligro = peligro.to_crs(USE_CRS)\npeligro = peligro[peligro[\"PELIGROSID\"] != \"baja\"]\n\npeligro_bounds = peligro.total_bounds\npeligro_bbox = box(*peligro_bounds)\n\npeligro_la_plata = peligro.clip(la_plata)\npeligro_clipped_3857 = peligro_la_plata.to_crs(WEB_MERCATOR_CRS)\n\n\nrenabap_pba_intersect = renabap_pba[\n    renabap_pba.geometry.intersects(la_plata_bbox)\n].copy()\n\n\nif os.path.exists(CUENCAS_PATH):\n    cuencas = gpd.read_file(CUENCAS_PATH)\nelse:\n    params = {\"where\": \"1=1\", \"outFields\": \"*\", \"f\": \"geojson\"}\n\n    cuencas_response = requests.get(CUENCAS_API_URL, params=params)\n    with open(CUENCAS_PATH, \"w\", encoding=\"utf-8\") as f:\n        f.write(cuencas_response.text)\n\n    cuencas = gpd.read_file(StringIO(cuencas_response.text))\n\ncuencas = cuencas.to_crs(USE_CRS)\ncuencas = cuencas.clip(la_plata)\n\n# Map watershed names to axes based on the EJE_MAPPING\ncuencas[\"eje\"] = (\n    cuencas[\"Cuenca\"]\n    .map(\n        {\n            cuenca: eje\n            for eje, cuencas_list in EJE_MAPPING.items()\n            for cuenca in cuencas_list\n        }\n    )\n    .fillna(\"otro\")\n)\n\n# Calculate total area of RENABAP settlements in hectares (POSGAR projection is in meters)\nrenabap_total_area_ha = (\n    renabap_pba_intersect.geometry.area.sum() / 10000\n)  # Convert m to hectares\nla_plata_area_ha = la_plata.geometry.iloc[0].area / 10000\npercentage_coverage = (renabap_total_area_ha / la_plata_area_ha) * 100\n\n# Get common bounds for all maps\ncommon_bounds = la_plata.total_bounds\n\n# Intersect settlements with hazard zones\nsettlement_hazard = gpd.overlay(renabap_pba_intersect, peligro, how=\"intersection\")\n\nsettle_hazard_cuencas = gpd.overlay(\n    settlement_hazard, cuencas, how=\"intersection\", keep_geom_type=True\n)\n\nif os.path.exists(BUILDINGS_PATH):\n    buildings = gpd.read_parquet(BUILDINGS_PATH)\nelse:\n    buildings = fetch_buildings(la_plata.buffer(500))\n\n\nla_plata_buffered = la_plata_bbox.buffer(500)\nbuildings_proj = buildings.to_crs(USE_CRS)\nbuildings_proj = buildings_proj[buildings_proj.geometry.intersects(la_plata_buffered)]",
    "crumbs": [
      "<span class='chapter-number'>4</span> <span class='chapter-title'>RENABAP</span>"
    ]
  },
  {
    "objectID": "renabap.html#fuentes-de-datos",
    "href": "renabap.html#fuentes-de-datos",
    "title": "4 RENABAP",
    "section": "4.3 Fuentes de datos",
    "text": "4.3 Fuentes de datos\n\n4.3.1 RENABAP\nEl Registro Nacional de barrios populares (RENABAP), coordinado por la Subsecretar칤a de Integraci칩n Socio Urbana, sistematiza la informaci칩n sobre los barrios populares en Argentina.1 El registro incluye estimaciones de poblaci칩n, delimitaciones geogr치ficas y datos sociodemogr치ficos, obtenidos a trav칠s de relevamientos territoriales realizados desde 2016 por equipos conformados por organizaciones sociales y vecinos de los barrios.\nEste relevamiento de viviendas familiares se lleva a cabo a trav칠s de encuestas domiciliarias en los barrios populares registrados. La metodolog칤a combina el trabajo territorial con herramientas digitales, como aplicaciones m칩viles de geolocalizaci칩n, escaneo de DNI, grabaci칩n de encuestas y cartograf칤a editable. Cada pol칤gono barrial se subdivide en manzanas, lotes y edificaciones y se completa una ficha por cada vivienda habitada. Los datos son validados con organismos oficiales (RENAPER, ANSES) y sometidos a controles de calidad para garantizar su precisi칩n.\nLas estimaciones poblacionales para la versi칩n 2023 fueron calculadas multiplicando la cantidad de viviendas registradas en el RENABAP, por el promedio de personas por vivienda y el promedio de hogares por vivienda, seg칰n los datos del Censo Nacional de Poblaci칩n, Hogares y Viviendas (INDEC 2010) aplicados a cada barrio. Esta metodolog칤a reduce la precisi칩n de los datos demogr치ficos, especialmente en contextos de transformaci칩n urbana acelerada, dado que muchos barrios populares han experimentado cambios sustanciales desde 2010. Las implicancias cr칤ticas de estas limitaciones se analizan en profundidad en la secci칩n correspondiente de este estudio.\nM치s informaci칩n sobre el RENABAP puede consultarse en el Observatorio de Barrios Populares. Los datos utilizados fueron obtenidos a trav칠s del Mapa de Barrios Populares y est치n disponibles para descarga como GeoJSON.\n\n\n4.3.2 Peligro de inundaci칩n\nLos datos del peligro de inundaci칩n utilizados en este an치lisis fueron desarrollados por la Facultad de Ingenier칤a de la Universidad Nacional de La Plata, en el marco del Plan de Reducci칩n del Riesgo por Inundaciones (PRRI) en la Regi칩n de La Plata (P. Romanazzi et al. 2019; P. G. Romanazzi, Mena, and Valinoti 2023). La informaci칩n fue generada mediante la aplicaci칩n del modelo hidrol칩gico-hidr치ulico bidimensional FLO-2D, que permiti칩 simular la din치mica de inundaci칩n de todas las cuencas del partido de La Plata para distintos escenarios de eventos pluviom칠tricos extremos.\nEste modelo calcula las principales variables hidr치ulicas (altura del agua, velocidad y caudal) a lo largo del tiempo. A partir de estos resultados se elaboraron mapas de peligrosidad que combinan la profundidad con la velocidad de la corriente, ofreciendo un indicador m치s completo que los mapas tradicionales basados 칰nicamente en m치ximas profundidades.\nEn el caso espec칤fico de la Cuenca del Arroyo Maldonado, el modelo digital de terreno (MDT) fue actualizado en 2024 como parte del proyecto de investigaci칩n Construyendo Resiliencia del Centro de Investigaciones Urbanas y Territoriales (Etula칤n 2023). Esta actualizaci칩n se realiz칩 mediante un relevamiento topogr치fico detallado de todas las esquinas y calles de la cuenca, as칤 como de diversas secciones del cauce del arroyo, con el objetivo de capturar con mayor precisi칩n los patrones de drenaje y la topograf칤a urbana de la ciudad (Carner, Ortiz, and Lacunza en edici칩n).\nEl an치lisis a escala del Partido de La Plata se basa espec칤ficamente en los datos de peligrosidad generados para el escenario de la Precipitaci칩n M치xima Probable (PMP), utilizado en el PRRI. Para el caso de la Cuenca del Arroyo Maldonado, se realiz칩 un an치lisis comparativo de la exposici칩n al riesgo seg칰n per칤odos de retorno: 25 a침os, 100 a침os (Etula칤n 2023) y la PMP del PRRI (P. Romanazzi et al. 2019).\n\n\n4.3.3 Google-Microsoft-OSM Open Buildings\nLos datos de Google-Microsoft-OSM Open Buildings (VIDA 2023) brindan una herramienta m치s precisa para identificar la ubicaci칩n de los asentamientos humanos. Este conjunto integra huellas edilicias provenientes de Google V3 Open Buildings, Microsoft GlobalMLFootprints, y OpenStreetMap building footprints, conteniendo m치s de 2.7 mil millones de edificaciones georreferenciadas.\nEstos datos han sido utilizados en evaluaciones de riesgo de inundaci칩n por empresas globales de riesgo financiero, como ICE, demostrando su utilidad para mapear la exposici칩n clim치tica a nivel de huella individual. Su resoluci칩n espacial permite estimar con mayor detalle la distribuci칩n de las estructuras habitacionales en el 치rea analizada.\nSin embargo, en ausencia de informaci칩n sobre el uso espec칤fico de cada edificaci칩n (residencial, comercial, institucional), y sin datos sobre el n칰mero de unidades habitacionales ni de habitantes por edificio, las estimaciones poblacionales que podemos obtener de estas huellas son necesariamente aproximadas. Podemos inferir patrones de ocupaci칩n espacial, pero no acceder a una comprensi칩n precisa sobre qui칠n vive all칤 ni cu치ntas personas habitan cada estructura.\n\n\n4.3.4 L칤mites municipales\nLos l칤mites municipales del Partido de La Plata fueron obtenidos del Instituto Geogr치fico Nacional (Instituto Geogr치fico Nacional 2025). Los datos representan la divisi칩n pol칤tico-administrativa de tercer orden que incluye comunas, juntas vecinales y dem치s formas de gobiernos.\n\n\n4.3.5 Cuencas hidrogr치ficas\nLos datos de cuencas hidrogr치ficas fueron obtenidos de la Divisi칩n Provincial de Hidr치ulica de la Provincia de Buenos Aires (Divisi칩n Provincial de Hidr치ulica - Provincia de Buenos Aires 2025).",
    "crumbs": [
      "<span class='chapter-number'>4</span> <span class='chapter-title'>RENABAP</span>"
    ]
  },
  {
    "objectID": "renabap.html#contexto",
    "href": "renabap.html#contexto",
    "title": "4 RENABAP",
    "section": "4.4 Contexto",
    "text": "4.4 Contexto\n\n\nMostrar c칩digo\n# Calcular variables para el contexto\ntotal_barrios = int(len(renabap_pba_intersect))\ntotal_familias = int(renabap_pba_intersect[\"familias_aproximadas\"].sum())\narea_barrios_ha = int(renabap_total_area_ha)\nporcentaje_cobertura = float(round(percentage_coverage, 1))\n\n# Calcular barrios que intersectan con zonas de peligro\nbarrios_with_peligro = gpd.sjoin(\n    renabap_pba_intersect, peligro_la_plata, how=\"inner\", predicate=\"intersects\"\n)\n\n# Contar barrios por nivel de peligro\nbarrios_peligro_alta = int(\n    len(\n        barrios_with_peligro[barrios_with_peligro[\"PELIGROSID\"] == \"alta\"][\n            \"id_renabap\"\n        ].unique()\n    )\n)\nbarrios_peligro_media = int(\n    len(\n        barrios_with_peligro[barrios_with_peligro[\"PELIGROSID\"] == \"media\"][\n            \"id_renabap\"\n        ].unique()\n    )\n)\n\n# Contar barrios por tipo de peligro (sin duplicados)\nbarrios_peligro_summary = (\n    barrios_with_peligro.groupby(\"id_renabap\")[\"PELIGROSID\"]\n    .agg([\"nunique\", \"unique\"])\n    .reset_index()\n)\nbarrios_peligro_summary[\"tiene_alta\"] = barrios_peligro_summary[\"unique\"].apply(\n    lambda x: \"alta\" in x\n)\nbarrios_peligro_summary[\"tiene_media\"] = barrios_peligro_summary[\"unique\"].apply(\n    lambda x: \"media\" in x\n)\n\n# Contar barrios por categor칤a\nbarrios_solo_alta = int(\n    (\n        barrios_peligro_summary[\"tiene_alta\"] & ~barrios_peligro_summary[\"tiene_media\"]\n    ).sum()\n)\nbarrios_solo_media = int(\n    (\n        barrios_peligro_summary[\"tiene_media\"] & ~barrios_peligro_summary[\"tiene_alta\"]\n    ).sum()\n)\nbarrios_ambos_peligros = int(\n    (\n        barrios_peligro_summary[\"tiene_alta\"] & barrios_peligro_summary[\"tiene_media\"]\n    ).sum()\n)\n\n# Total de barrios que intersectan con cualquier nivel de peligro (sin duplicados)\nbarrios_total_peligro = int(len(barrios_with_peligro[\"id_renabap\"].unique()))\n\n# Obtener total de edificios en La Plata\ntotal_buildings_la_plata = len(buildings_proj)\n\n# Obtener todas las edificios que intersectan con los barrios (corregir warning de deprecaci칩n)\nbuildings_in_barrios = buildings_proj[\n    buildings_proj.geometry.intersects(renabap_pba_intersect.union_all())\n]\ntotal_buildings_in_barrios = len(buildings_in_barrios)\n\nviviendas_faltantes = (\n    total_buildings_in_barrios - 30753\n)  # 30753 es el n칰mero oficial de RENABAP\n\n# Calcular porcentaje de edificios en barrios\nbuildings_percentage = float(\n    round((total_buildings_in_barrios / total_buildings_la_plata) * 100, 1)\n)\n\n# Calcular 치rea total de barrios populares en hect치reas\nbarrios_total_area_ha = float(round(renabap_pba_intersect.geometry.area.sum() / 10000, 1))\n\n# Calcular el 치rea real de superposici칩n entre barrios populares y zonas de peligro\n# Primero, crear uniones de las zonas de peligro por tipo\npeligro_alta_union = peligro_la_plata[peligro_la_plata[\"PELIGROSID\"] == \"alta\"].union_all()\npeligro_media_union = peligro_la_plata[peligro_la_plata[\"PELIGROSID\"] == \"media\"].union_all()\n\n# Calcular el 치rea de superposici칩n real entre barrios y zonas de peligro alto\nbarrios_intersect_alta = renabap_pba_intersect.copy()\nbarrios_intersect_alta[\"geometry\"] = renabap_pba_intersect.geometry.intersection(peligro_alta_union)\nbarrios_intersect_alta = barrios_intersect_alta[~barrios_intersect_alta.geometry.is_empty]\nbarrios_area_peligro_alta_ha = float(round(barrios_intersect_alta.geometry.area.sum() / 10000, 1))\nbarrios_pct_peligro_alta = float(round((barrios_area_peligro_alta_ha / barrios_total_area_ha) * 100, 1))\n\n# Calcular el 치rea de superposici칩n real entre barrios y zonas de peligro medio\nbarrios_intersect_media = renabap_pba_intersect.copy()\nbarrios_intersect_media[\"geometry\"] = renabap_pba_intersect.geometry.intersection(peligro_media_union)\nbarrios_intersect_media = barrios_intersect_media[~barrios_intersect_media.geometry.is_empty]\nbarrios_area_peligro_media_ha = float(round(barrios_intersect_media.geometry.area.sum() / 10000, 1))\nbarrios_pct_peligro_media = float(round((barrios_area_peligro_media_ha / barrios_total_area_ha) * 100, 1))\n\n# Calcular el 치rea total de barrios populares como porcentaje del partido\nbarrios_pct_del_partido = float(round((barrios_total_area_ha / la_plata_area_ha) * 100, 1))\n\n\n\n\n# Calcular 치rea para cada tipo de peligro en hect치reas\npeligro_areas = (\n    peligro_la_plata.groupby(\"PELIGROSID\")[\"geometry\"]\n    .apply(\n        lambda x: x.area.sum() / 10000  # Convertir m a hect치reas\n    )\n    .reset_index()\n)\npeligro_areas.columns = [\"tipo_peligro\", \"area_ha\"]\n\n# Calcular porcentajes\npeligro_areas[\"porcentaje\"] = (peligro_areas[\"area_ha\"] / la_plata_area_ha) * 100\n\n# Variables para cada nivel de peligro (convertir a float Python nativo)\npeligro_alta_ha = float(\n    round(peligro_areas[peligro_areas[\"tipo_peligro\"] == \"alta\"][\"area_ha\"].iloc[0], 1)\n)\npeligro_alta_pct = float(\n    round(\n        peligro_areas[peligro_areas[\"tipo_peligro\"] == \"alta\"][\"porcentaje\"].iloc[0], 1\n    )\n)\npeligro_media_ha = float(\n    round(peligro_areas[peligro_areas[\"tipo_peligro\"] == \"media\"][\"area_ha\"].iloc[0], 1)\n)\npeligro_media_pct = float(\n    round(\n        peligro_areas[peligro_areas[\"tipo_peligro\"] == \"media\"][\"porcentaje\"].iloc[0], 1\n    )\n)\n\n# 츼rea total cubierta por zonas de peligro (convertir a float Python nativo)\narea_total_peligro_ha = float(round(peligro_areas[\"area_ha\"].sum(), 1))\nporcentaje_total_peligro = float(round(peligro_areas[\"porcentaje\"].sum(), 1))\n\n\nSeg칰n los datos oficiales de RENABAP, hay un total de 33.888 familias y 30.753 viviendas en 166 barrios populares en el Partido de La Plata. Sin embargo, estos datos fueron creados bas치ndose en proyecciones del Censo Argentino de 2010 hacia 2023. Nuestro an치lisis de datos de huellas de edificaciones encuentra un total de 72.328 techos en barrios populares en La Plata, representando aproximadamente 41.575 edificaciones adicionales que no est치n contabilizadas en los datos oficiales.\nLos barrios populares ocupan un total de 1.760,9 hect치reas, representando el 2,0% del territorio total del Partido de La Plata (89.667,9 hect치reas). El Partido de La Plata incluye 4.202,3 hect치reas en peligro de inundaci칩n alto (4,7% del partido) y 19.515,0 hect치reas en peligro de inundaci칩n medio (21,8% del partido) bajo el escenario de PMP.\nRespecto a la exposici칩n de los barrios populares al peligro de inundaci칩n, se identific칩 que 124 barrios (74,7% del total) est치n localizados en zonas con peligro alto o medio de inundaci칩n. Espec칤ficamente, 1 barrio est치 칰nicamente en zona de peligro alto, 46 barrios est치n 칰nicamente localizados en zona de peligro medio, y 77 barrios presentan tanto peligro alto como medio dentro de sus l칤mites. En t칠rminos de 치rea de superposici칩n 153,5 hect치reas (8,7% del 치rea total de barrios populares) se superponen con zonas de peligro alto, mientras que 310,1 hect치reas (17,6% del 치rea total de barrios populares) se superponen con zonas de peligro medio.\n\nMostrar c칩digo\nfig1, ax1 = create_consistent_map(\n    \"Asentamientos RENABAP en La Plata\", crs=USE_CRS, boundary_gdf=la_plata, bounds=common_bounds, attribution=\"Datos: RENABAP (2023), IGN (2025) | Mapa base: Carto (2025)\", scalebar_length=0.20\n)\n\nrenabap_pba_intersect_3857 = renabap_pba_intersect.to_crs(WEB_MERCATOR_CRS)\n\nrenabap_pba_intersect_3857.plot(\n    ax=ax1, facecolor=\"none\", edgecolor=\"black\", linewidth=0.5, legend=False, zorder=10\n)\n\nplt.tight_layout()\nplt.show()\n\n\n\n# Reorder the categories so they map correctly to plasma colormap\npeligro_clipped_3857[\"PELIGROSID_ordered\"] = pd.Categorical(\n    peligro_clipped_3857[\"PELIGROSID\"],\n    categories=[\"media\", \"alta\"],\n    ordered=True,\n)\n\n\nfig2, ax2 = create_consistent_map(\n    \"Zonas de Peligro en La Plata\", crs=USE_CRS, boundary_gdf=la_plata, bounds=common_bounds, attribution=\"Datos: Romanazzi et al. (2019), IGN (2025) | Mapa base: Carto (2025)\", scalebar_length=0.20\n)\n\n\ncolor_map = peligro_clipped_3857[\"PELIGROSID\"].map(PELIGROSIDAD_COLORS)\n\npeligro_clipped_3857.plot(\n    ax=ax2,\n    color=color_map,\n    alpha=0.75,\n    zorder=5,\n)\n\nax2.legend(handles=PELIGROSIDAD_LEGEND, loc=\"lower right\")\n\nplt.tight_layout()\nplt.show()\n\n\nfig3, ax3 = create_consistent_map(\n    \"Huellas de edificios\", crs=USE_CRS, boundary_gdf=la_plata, bounds=common_bounds, attribution=\"Datos: VIDA (2023), IGN (2025) | Mapa base: Carto (2025)\", scalebar_length=0.20\n)\n\nbuildings_3857 = buildings_proj.to_crs(WEB_MERCATOR_CRS)\n\nbuildings_3857.plot(ax=ax3, facecolor=\"grey\", edgecolor=\"none\", alpha=0.7)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Asentamientos RENABAP en La Plata\n\n\n\n\n\n\n\n\n\n\n\n(b) Zonas de Peligro en La Plata\n\n\n\n\n\n\n\n\n\n\n\n(c) Huellas de edificios\n\n\n\n\n\n\n\nFigure4.1: Fuentes de datos para an치lisis de exposici칩n",
    "crumbs": [
      "<span class='chapter-number'>4</span> <span class='chapter-title'>RENABAP</span>"
    ]
  },
  {
    "objectID": "renabap.html#metodolog칤a",
    "href": "renabap.html#metodolog칤a",
    "title": "4 RENABAP",
    "section": "4.5 Metodolog칤a",
    "text": "4.5 Metodolog칤a\nEn versiones anteriores de este an치lisis, el trabajo se realiz칩 mediante una interpolaci칩n areal simple del porcentaje de superposici칩n de cada 치rea de peligro de inundaci칩n con los barrios populares. Este enfoque presenta dos problemas fundamentales que este estudio busca abordar.\nEl primer problema es que la interpolaci칩n areal es inherentemente imprecisa, ya que asume lo que se conoce como el problema de la unidad areal modificable y presupone que la poblaci칩n se distribuye uniformemente en el espacio. Estudios confirman que cuando se asume distribuci칩n uniforme de poblaci칩n en 치reas extensas (como datos de censo a nivel de secci칩n), las estimaciones de exposici칩n a inundaciones son inexactas, requiriendo datos de mayor resoluci칩n que no asuman distribuci칩n uniforme (Smith et al. 2019). La poblaci칩n, de hecho, no se distribuye uniformemente en el espacio; frecuentemente las edificaciones se agrupan ya sea alej치ndose de las zonas de peligro de inundaci칩n o concentr치ndose en zonas de alto peligro de inundaci칩n. Por tanto, es fundamental comprender con estimaciones m치s precisas d칩nde vive realmente la gente.\nEl segundo problema radica en que los propios datos del RENABAP, seg칰n nuestro an치lisis aqu칤 presentado, parecen contar de forma incorrecta tanto el dato de familias como de viviendas pertenecientes a un barrio, dado que se ha comprobado la existencia de muchas m치s edificaciones que las viviendas que indican los datos oficiales, en un total de 41.575 techos o edificaciones de m치s.\nEste hallazgo ha sido posible debido a la existencia de las huellas de edificaciones globales derivadas de sat칠lite que han surgido en los 칰ltimos a침os de Google-Microsoft-OSM, entre otros. Uno de los objetivos principales de este an치lisis es demostrar que estos datos pueden utilizarse para estimar la exposici칩n de manera m치s precisa, tanto en t칠rminos metodol칩gicos como en la mejora sobre conjuntos de datos nacionales existentes, en este caso del RENABAP.\nPor tanto, en este estudio utilizamos el n칰mero de edificaciones que se localizan en diferentes zonas de peligro de inundaci칩n, diferenciando entre alta y media y utilizando espec칤ficamente los datos de peligrosidad generados para el escenario de PMP. Aunque los datos del RENABAP estiman aproximadamente 1,1 familias por vivienda, medimos la exposici칩n en t칠rminos del n칰mero comparativo de techos o edificaciones, lo cual es suficiente para demostrar las limitaciones del RENABAP y proporcionar estimaciones razonablemente m치s ajustadas a la realidad en cuanto a la exposici칩n de la poblaci칩n vulnerable frente a inundaciones.\nBas치ndonos en conversaciones con funcionarios municipales y acad칠micos, asumimos que la mayor칤a de las edificaciones en barrios populares son residenciales de uno a dos pisos, creando una correspondencia estrecha entre n칰mero de edificaciones y familias. Esta suposici칩n es v치lida para este contexto espec칤fico, aunque no aplicar칤a para 치reas urbanas con edificios en altura.\n\n\nMostrar c칩digo\n# Definir orden de prioridad de peligro y simplificar\nhazard_priority = {\"alta\": 2, \"media\": 1}\npeligro_simple = peligro_la_plata.dissolve(by=\"PELIGROSID\").reset_index()\n\n# Construir 칤ndices espaciales para operaciones m치s r치pidas\nbuildings_proj.sindex\nrenabap_pba_intersect.sindex\npeligro_simple.sindex\n\n# Filtrar edificios a solo aquellos que podr칤an intersectar con barrios\n# usando intersecci칩n de cajas delimitadoras primero (mucho m치s r치pido que intersecci칩n geom칠trica)\n# Crear una uni칩n de todas las cajas delimitadoras individuales de barrios\n\n\n# Obtener cajas delimitadoras individuales para cada barrio\nbarrio_boxes = []\nfor _, barrio in renabap_pba_intersect.iterrows():\n    bounds = barrio.geometry.bounds\n    barrio_boxes.append(box(bounds[0], bounds[1], bounds[2], bounds[3]))\n\n# Crear una uni칩n de todas las cajas delimitadoras de barrios\n\n\nbarrios_union = unary_union(barrio_boxes)\n\n# Filtrar edificios a solo aquellos que intersectan con cualquier caja delimitadora de barrio\nbuildings_candidates = buildings_proj[buildings_proj.geometry.intersects(barrios_union)]\n\n# Ahora hacer el join espacial en el dataset filtrado mucho m치s peque침o\nbuildings_with_barrios = gpd.sjoin(\n    buildings_candidates,\n    renabap_pba_intersect[\n        [\"id_renabap\", \"nombre_barrio\", \"familias_aproximadas\", \"geometry\"]\n    ],\n    how=\"inner\",\n    predicate=\"within\",\n)\n\nbuildings_with_barrios = buildings_with_barrios.drop(columns=[\"index_right\"]).copy()\n\n# Etapa 1: Obtener edificios que est치n claramente dentro de zonas de peligro (r치pido)\nbuildings_within_hazards = gpd.sjoin(\n    buildings_with_barrios,\n    peligro_simple[[\"PELIGROSID\", \"geometry\"]],\n    how=\"inner\",\n    predicate=\"within\",\n)\n\n# Etapa 2: Encontrar edificios que est치n cerca de los l칤mites de peligro pero no dentro\n# Usar un peque침o buffer alrededor de las zonas de peligro para encontrar casos l칤mite potenciales\nhazard_buffered = peligro_simple.copy()\nhazard_buffered[\"geometry\"] = peligro_simple.geometry.buffer(5)  # buffer de 5 metros\n\nbuildings_near_hazards = gpd.sjoin(\n    buildings_with_barrios,\n    hazard_buffered[[\"PELIGROSID\", \"geometry\"]],\n    how=\"inner\",\n    predicate=\"within\",\n)\n\n# Encontrar casos l칤mite (cerca de peligros pero no dentro de los peligros originales)\nwithin_ids = set(buildings_within_hazards.index)\nnear_ids = set(buildings_near_hazards.index)\nedge_case_ids = near_ids - within_ids\n\nbuildings_edge_cases = buildings_with_barrios.loc[list(edge_case_ids)]\n\n# Etapa 3: Usar intersects solo en los casos l칤mite\nbuildings_edge_cases_with_hazard = gpd.sjoin(\n    buildings_edge_cases,\n    peligro_simple[[\"PELIGROSID\", \"geometry\"]],\n    how=\"left\",\n    predicate=\"intersects\",\n)\n\n# Combinar resultados\nbuildings_with_peligro_barrio = pd.concat(\n    [buildings_within_hazards, buildings_edge_cases_with_hazard], ignore_index=True\n)\n\n\n# Resolver duplicados y contar\nbuildings_barrio_final = buildings_with_peligro_barrio.dropna(\n    subset=[\"PELIGROSID\"]\n).copy()\nbuildings_barrio_final.loc[:, \"prioridad\"] = buildings_barrio_final[\"PELIGROSID\"].map(\n    hazard_priority\n)\nbuildings_barrio_unique = buildings_barrio_final.sort_values(\n    \"prioridad\", ascending=False\n).drop_duplicates(subset=buildings_barrio_final.geometry.name, keep=\"first\")\n\n# Calcular exposici칩n por barrio\nedificios_por_barrio_peligro = (\n    buildings_barrio_unique.groupby([\"id_renabap\", \"PELIGROSID\"])\n    .size()\n    .reset_index(name=\"edificios_expuestos\")\n)\n\ntotal_edificios_barrio = (\n    buildings_with_barrios.groupby(\"id_renabap\")\n    .size()\n    .reset_index(name=\"total_edificios\")\n)\n\nexposure_barrio = edificios_por_barrio_peligro.merge(\n    total_edificios_barrio, on=\"id_renabap\"\n)\nexposure_barrio[\"proporcion\"] = (\n    exposure_barrio[\"edificios_expuestos\"] / exposure_barrio[\"total_edificios\"]\n)\n\nfamilias_barrio = renabap_pba_intersect[\n    [\"id_renabap\", \"nombre_barrio\", \"familias_aproximadas\"]\n].drop_duplicates()\nfinal_exposure_barrio = exposure_barrio.merge(familias_barrio, on=\"id_renabap\")\nfinal_exposure_barrio[\"fam_expuestas\"] = (\n    final_exposure_barrio[\"proporcion\"] * final_exposure_barrio[\"familias_aproximadas\"]\n)\n\nresultado_exposicion_barrio = final_exposure_barrio[\n    [\n        \"id_renabap\",\n        \"nombre_barrio\",\n        \"PELIGROSID\",\n        \"edificios_expuestos\",\n    ]\n].rename(columns={\"PELIGROSID\": \"peligrosidad\"})\n\n# === AN츼LISIS POR CUENCA ===\n# Usar edificios ya en barrios para an치lisis de cuenca\nbuildings_in_settlements = buildings_with_barrios.copy()\n\n# Spatial joins para cuenca\nbuildings_with_cuenca = gpd.sjoin(\n    buildings_in_settlements,\n    cuencas[[\"Cuenca\", \"eje\", \"geometry\"]],\n    how=\"left\",\n    predicate=\"within\",\n)\nbuildings_with_cuenca = buildings_with_cuenca.drop(columns=[\"index_right\"]).copy()\n\nbuildings_with_peligro_cuenca = gpd.sjoin(\n    buildings_in_settlements,\n    peligro_simple[[\"PELIGROSID\", \"geometry\"]],\n    how=\"left\",\n    predicate=\"within\",\n)\n\n# Combinar y filtrar\nbuildings_cuenca_final = buildings_in_settlements.copy()\nbuildings_cuenca_final.loc[:, \"Cuenca\"] = buildings_with_cuenca[\"Cuenca\"]\nbuildings_cuenca_final.loc[:, \"eje\"] = buildings_with_cuenca[\"eje\"]\nbuildings_cuenca_final.loc[:, \"PELIGROSID\"] = buildings_with_peligro_cuenca[\n    \"PELIGROSID\"\n]\nbuildings_cuenca_final = buildings_cuenca_final.dropna(\n    subset=[\"Cuenca\", \"PELIGROSID\"]\n).copy()\n\n# Resolver duplicados y calcular exposici칩n por cuenca\nbuildings_cuenca_final.loc[:, \"prioridad\"] = buildings_cuenca_final[\"PELIGROSID\"].map(\n    hazard_priority\n)\nbuildings_cuenca_unique = buildings_cuenca_final.sort_values(\n    \"prioridad\", ascending=False\n).drop_duplicates(subset=buildings_cuenca_final.geometry.name, keep=\"first\")\n\nedificios_por_cuenca_peligro = (\n    buildings_cuenca_unique.groupby([\"Cuenca\", \"PELIGROSID\"])\n    .size()\n    .reset_index(name=\"edificios_expuestos\")\n)\n\ntotal_edificios_cuenca = (\n    buildings_with_cuenca.dropna(subset=[\"Cuenca\"])\n    .groupby(\"Cuenca\")\n    .size()\n    .reset_index(name=\"total_edificios\")\n)\n\nexposure_cuenca = edificios_por_cuenca_peligro.merge(\n    total_edificios_cuenca, on=\"Cuenca\"\n)\nexposure_cuenca[\"proporcion\"] = (\n    exposure_cuenca[\"edificios_expuestos\"] / exposure_cuenca[\"total_edificios\"]\n)\n\nfamilias_cuenca = (\n    settle_hazard_cuencas.drop_duplicates(\"id_renabap\")\n    .groupby(\"Cuenca\")[\"familias_aproximadas\"]\n    .sum()\n    .reset_index()\n)\n\nfinal_exposure_cuenca = exposure_cuenca.merge(familias_cuenca, on=\"Cuenca\")\nfinal_exposure_cuenca[\"fam_expuestas\"] = (\n    final_exposure_cuenca[\"proporcion\"] * final_exposure_cuenca[\"familias_aproximadas\"]\n)\n\nresultado_exposicion_cuenca = final_exposure_cuenca[\n    [\"Cuenca\", \"PELIGROSID\", \"edificios_expuestos\"]\n].rename(columns={\"PELIGROSID\": \"peligrosidad\"})\n\n# === AN츼LISIS POR EJE ===\n# Usar los edificios ya procesados con cuenca y peligro\nbuildings_eje_final = buildings_cuenca_final.dropna(subset=[\"eje\"]).copy()\n\n# Resolver duplicados por prioridad de peligro\nbuildings_eje_final.loc[:, \"prioridad\"] = buildings_eje_final[\"PELIGROSID\"].map(\n    hazard_priority\n)\nbuildings_eje_unique = buildings_eje_final.sort_values(\n    \"prioridad\", ascending=False\n).drop_duplicates(subset=buildings_eje_final.geometry.name, keep=\"first\")\n\n# Calcular exposici칩n por eje y peligrosidad\nedificios_por_eje_peligro = (\n    buildings_eje_unique.groupby([\"eje\", \"PELIGROSID\"])\n    .size()\n    .reset_index(name=\"edificios_expuestos\")\n)\n\ntotal_edificios_eje = (\n    buildings_with_cuenca.dropna(subset=[\"eje\"])\n    .groupby(\"eje\")\n    .size()\n    .reset_index(name=\"total_edificios\")\n)\n\nexposure_eje = edificios_por_eje_peligro.merge(total_edificios_eje, on=\"eje\")\nexposure_eje[\"proporcion\"] = (\n    exposure_eje[\"edificios_expuestos\"] / exposure_eje[\"total_edificios\"]\n)\n\nfamilias_por_eje = (\n    settle_hazard_cuencas.drop_duplicates(\"id_renabap\")\n    .groupby(\"eje\")[\"familias_aproximadas\"]\n    .sum()\n    .reset_index()\n)\n\nfinal_exposure_eje = exposure_eje.merge(familias_por_eje, on=\"eje\")\nfinal_exposure_eje[\"fam_expuestas\"] = (\n    final_exposure_eje[\"proporcion\"] * final_exposure_eje[\"familias_aproximadas\"]\n)\n\nresultado_exposicion_eje = final_exposure_eje[\n    [\"eje\", \"PELIGROSID\", \"edificios_expuestos\"]\n].rename(columns={\"PELIGROSID\": \"peligrosidad\"})\n\n\n\n4.5.1 Limitaciones de los datos del RENABAP\nLos datos del RENABAP presentan limitaciones importantes que justifican el uso de huellas de edificaciones como alternativa m치s precisa. Los datos m치s recientes del RENABAP de 2023 subestiman significativamente el n칰mero total de familias por barrio popular. Estos datos -como se ha mencionado- se basan en proyecciones derivadas del censo de 2010, lo que ha resultado en estimaciones considerablemente desactualizadas.\n\n\nMostrar c칩digo\n# =============================================================================\n# ANALYTICAL PROCESSING: RENABAP DATA VALIDATION\n# =============================================================================\n\n# Calcular familias estimadas basadas en edificios (1,1 familias por edificio)\nratio_fam_edif = (\n    buildings_with_barrios.groupby([\"id_renabap\", \"familias_aproximadas\"])\n    .size()\n    .reset_index(name=\"total_edificios\")\n)\n\nratio_fam_edif[\"familias_estimadas_edificios\"] = ratio_fam_edif[\"total_edificios\"] * 1.1\n# Calcular el error porcentual: (RENABAP - Edificios) / Edificios * 100\nratio_fam_edif[\"error_porcentual\"] = (\n    (\n        ratio_fam_edif[\"familias_aproximadas\"]\n        - ratio_fam_edif[\"familias_estimadas_edificios\"]\n    )\n    / ratio_fam_edif[\"familias_estimadas_edificios\"]\n) * 100\n\n# =============================================================================\n# GRAPHICS: RENABAP ERROR ANALYSIS\n# =============================================================================\n\n# Crear histograma\nplt.figure(figsize=(12, 6))\nplt.hist(\n    ratio_fam_edif[\"error_porcentual\"],\n    bins=30,\n    edgecolor=\"none\",\n    color=PELIGROSIDAD_COLORS[\"media\"],\n)\n\n# Personalizar el gr치fico\nplt.title(\n    \"Error de Estimaci칩n de RENABAP vs Estimaci칩n por Edificios\",\n    fontsize=16,\n    fontweight=\"bold\",\n)\nplt.xlabel(\"Error Porcentual (%)\", fontsize=12)\nplt.ylabel(\"Frecuencia (N칰mero de Barrios)\", fontsize=12)\n\n# Agregar l칤neas de referencia\nmean_error = ratio_fam_edif[\"error_porcentual\"].mean()\nmedian_error = ratio_fam_edif[\"error_porcentual\"].median()\n\n# Rango de personas no contabilizadas (3-5 personas por vivienda)\npersonas_min_faltantes = round(viviendas_faltantes * 3, -3)  # Round to nearest thousand\npersonas_max_faltantes = round(viviendas_faltantes * 5, -3)  # Round to nearest thousand\n\nplt.axvline(\n    mean_error,\n    color=\"black\",\n    linestyle=\"--\",\n    linewidth=2,\n    label=f\"Error promedio: {mean_error:.1f}%\",\n)\nplt.axvline(\n    median_error,\n    color=\"black\",\n    linestyle=\"dotted\",\n    linewidth=2,\n    label=f\"Error mediano: {median_error:.1f}%\",\n)\n\n\nplt.legend()\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure4.2: Distribuci칩n del error porcentual en las estimaciones del RENABAP comparado con estimaciones basadas en edificios\n\n\n\n\n\nNuestro an치lisis comparativo entre los datos del RENABAP y el conteo de huellas de edificaciones o techos, revela que el RENABAP subestima el n칰mero de estructuras habitacionales en un promedio del 41%. A nivel agregado, esto se traduce en aproximadamente 41.575 viviendas faltantes que no est치n contabilizadas en las estad칤sticas oficiales del RENABAP. Si usamos la estimaci칩n del RENABAP de aproximadamente 1,1 familias por edificio, podemos considerar aproximadamente 45.732 familias. Tomando un rango razonable de 3 a 5 personas por familia, esta subestimaci칩n representa entre 137.000 y 229.000 personas que podr칤an estar no contabilizadas en los barrios populares. Esta discrepancia demuestra las limitaciones de los datos del RENABAP para la evaluaci칩n de la exposici칩n a riesgos de inundaci칩n y la planificaci칩n de pol칤ticas p칰blicas.\nTambi칠n podemos examinar im치genes satelitales de un barrio popular a modo de ejemplo, donde se analiza las huellas de las edificaciones superpuestas para tener una idea de la veracidad de los datos. En el barrio Los Pinos, las estimaciones del RENABAP dice que tiene solo 72 familias. Nuestros datos cuentan 519 edificaciones o techos, lo que debe corresponder a aproximadamente 570 familias (1,1 familia por edificaci칩n), que es casi ocho veces m치s que los datos que contabiliza el RENABAP.\nAl examinar otros ejemplos de barrios entre las huellas de edificaciones detectadas y los datos oficiales del RENABAP, observamos que frecuentemente encontramos 칩rdenes de magnitud de m치s edificaciones o techos que familias estimadas, representando miles de familias no contabilizadas.\n\n\nMostrar c칩digo\n# Filtrar para obtener solo el barrio con id_renabap 5688\nbarrio_5688 = renabap_pba_intersect[renabap_pba_intersect[\"id_renabap\"] == 5688].copy()\nif len(barrio_5688) == 0:\n    print(\"No se encontr칩 el barrio con id_renabap 5688\")\nelse:\n    # Obtener edificios en este barrio\n    buildings_5688 = buildings_with_barrios[\n        buildings_with_barrios[\"id_renabap\"] == 5688\n    ].copy()\n    # Convertir a Web Mercator\n    barrio_5688_3857 = barrio_5688.to_crs(WEB_MERCATOR_CRS)\n    buildings_5688_3857 = buildings_5688.to_crs(WEB_MERCATOR_CRS)\n    # Crear el mapa\n    fig, ax = plt.subplots(figsize=DEFAULT_FIGSIZE)\n    # Configurar l칤mites basados en el barrio\n    bounds = barrio_5688_3857.total_bounds\n    margin = 50  # metros\n    ax.set_xlim(bounds[0] - margin, bounds[2] + margin)\n    ax.set_ylim(bounds[1] - margin, bounds[3] + margin)\n    # Agregar basemap de contextily\n    cx.add_basemap(ax, crs=WEB_MERCATOR_CRS, source=cx.providers.Esri.WorldImagery, attribution=\"Datos: RENABAP (2023), VIDA (2023) | Mapa base: Esri (2025), Carto (2025)\")\n    # Plot de edificios con contorno naranja (sin fill)\n    buildings_5688_3857.plot(\n        ax=ax, facecolor=\"none\", edgecolor=PELIGROSIDAD_COLORS[\"media\"], linewidth=1\n    )\n    # Plot del l칤mite del barrio con estilo consistente\n    barrio_5688_3857.plot(\n        ax=ax,\n        facecolor=\"none\",\n        edgecolor=\"white\",  # White for satellite imagery visibility\n        linewidth=3,\n        linestyle=\"--\",\n        zorder=10,\n    )\n\n    cx.add_basemap(ax, crs=WEB_MERCATOR_CRS, source=cx.providers.CartoDB.PositronOnlyLabels, attribution=\"\")\n\n\n    scale_bar(\n        ax=ax,\n        location=\"upper left\",\n        style=\"ticks\",\n        bar={\n            \"projection\": \"axis\",\n            \"minor_type\": \"none\",\n            \"tickcolors\": \"white\",\n            \"basecolors\": \"white\",\n            \"max\": 100,\n        },\n        labels={\"style\": \"first_last\", \"textcolors\": [\"white\"], \"stroke_width\": 0},\n        units={\"label\": \"m\", \"textcolor\": \"white\", \"stroke_width\": 0},\n    )\n\n    north_arrow(\n        ax,\n        location=\"upper right\",\n        scale=0.3,  # Small size\n        rotation={\"degrees\": 0},\n        base={\"facecolor\": \"none\", \"edgecolor\": \"white\", \"linewidth\": 1},\n        fancy=True,\n        shadow=True,\n        label=False,  # Hide the \"N\" text\n    )\n\n    # Limpiar el mapa\n    barrio_nombre = barrio_5688[\"nombre_barrio\"].iloc[0]\n    familias_renabap = int(barrio_5688[\"familias_aproximadas\"].iloc[0])\n    total_edificios = len(buildings_5688)\n\n    # T칤tulo principal usando suptitle\n    fig.suptitle(\n        f\"Barrio {barrio_nombre} - L칤mites y edificios\",\n        fontsize=16,\n        fontweight=\"bold\",\n        y=0.98,\n    )\n\n    # Subt칤tulo usando title\n    ax.set_title(\n        f\"RENABAP: {familias_renabap} familias | Edificios detectados: {total_edificios}\",\n        fontsize=12,\n        style=\"italic\",\n        pad=30,\n    )\n    ax.set_xticks([])\n    ax.set_yticks([])\n    ax.set_xlabel(\"\")\n    ax.set_ylabel(\"\")\n    ax.spines[\"top\"].set_visible(False)\n    ax.spines[\"right\"].set_visible(False)\n    ax.spines[\"bottom\"].set_visible(False)\n    ax.spines[\"left\"].set_visible(False)\n    # Agregar leyenda simple\n    legend_elements = [\n        plt.Line2D([0], [0], color=\"white\", linewidth=3, label=\"L칤mite del barrio\"),\n        plt.Line2D(\n            [0],\n            [0],\n            color=PELIGROSIDAD_COLORS[\"media\"],\n            linewidth=1,\n            label=\"edificios\",\n        ),\n    ]\n    ax.legend(handles=legend_elements, loc=\"lower right\", bbox_to_anchor=(1.0, 0.02))\n    plt.tight_layout()\n    plt.show()\n\n\n\n\n\n\n\n\nFigure4.3: Ejemplo de discrepancia en los datos del RENABAP: el barrio Los Pinos con l칤mites oficiales y edificios detectadas\n\n\n\n\n\nAl examinar otros ejemplos de barrios con las mayores discrepancias entre las huellas de edificios detectadas y los datos oficiales del RENABAP, observamos que frecuentemente encontramos 칩rdenes de magnitud m치s edificios que familias estimadas, representando miles de familias no contabilizadas.\n\nMostrar c칩digo\n# IDs de los barrios a visualizar\nbarrio_ids = [4577, 65, 6541, 17]\n\nfor i, barrio_id in enumerate(barrio_ids):\n    # Filtrar para obtener el barrio espec칤fico\n    barrio_data = renabap_pba_intersect[\n        renabap_pba_intersect[\"id_renabap\"] == barrio_id\n    ].copy()\n\n    if len(barrio_data) == 0:\n        print(f\"No se encontr칩 el barrio con id_renabap {barrio_id}\")\n        continue\n\n    # Obtener edificios en este barrio\n    buildings_data = buildings_with_barrios[\n        buildings_with_barrios[\"id_renabap\"] == barrio_id\n    ].copy()\n\n    # Convertir a Web Mercator\n    barrio_3857 = barrio_data.to_crs(WEB_MERCATOR_CRS)\n    buildings_3857 = buildings_data.to_crs(WEB_MERCATOR_CRS)\n\n    # Crear el mapa individual\n    fig, ax = plt.subplots(figsize=DEFAULT_FIGSIZE)\n\n    # Configurar l칤mites basados en el barrio\n    bounds = barrio_3857.total_bounds\n    margin = 50  # metros\n    ax.set_xlim(bounds[0] - margin, bounds[2] + margin)\n    ax.set_ylim(bounds[1] - margin, bounds[3] + margin)\n\n    # Agregar basemap de contextily\n    cx.add_basemap(\n        ax, crs=WEB_MERCATOR_CRS, source=cx.providers.Esri.WorldImagery, attribution=\"Datos: RENABAP (2023), VIDA (2023) | Mapa base: Esri (2025)\"\n    )\n\n    # Plot de edificios con contorno naranja (sin fill)\n    buildings_3857.plot(\n        ax=ax, facecolor=\"none\", edgecolor=PELIGROSIDAD_COLORS[\"media\"], linewidth=1\n    )\n\n    # Plot del l칤mite del barrio con estilo consistente\n    barrio_3857.plot(\n        ax=ax,\n        facecolor=\"none\",\n        edgecolor=\"white\",\n        linewidth=3,\n        linestyle=\"--\",\n        zorder=10,\n    )\n\n\n    cx.add_basemap(ax, crs=WEB_MERCATOR_CRS, source=cx.providers.CartoDB.PositronOnlyLabels, attribution=\"\")\n\n    scale_bar(\n        ax=ax,\n        location=\"upper left\",\n        style=\"ticks\",\n        bar={\n            \"projection\": \"axis\",\n            \"minor_type\": \"none\",\n            \"tickcolors\": \"white\",\n            \"basecolors\": \"white\",\n            \"max\": 200,\n        },\n        labels={\"style\": \"first_last\", \"textcolors\": [\"white\"], \"stroke_width\": 0},\n        units={\"label\": \"m\", \"textcolor\": \"white\", \"stroke_width\": 0},\n    )\n\n    # Agregar flecha del norte\n    north_arrow(\n        ax,\n        location=\"upper right\",\n        scale=0.3,\n        rotation={\"degrees\": 0},\n        base={\"facecolor\": \"none\", \"edgecolor\": \"white\", \"linewidth\": 1},\n        fancy=True,\n        shadow=True,\n        label=False,\n    )\n\n    # Obtener informaci칩n del barrio\n    barrio_nombre = barrio_data[\"nombre_barrio\"].iloc[0]\n    familias_renabap = int(barrio_data[\"familias_aproximadas\"].iloc[0])\n    total_edificios = len(buildings_data)\n\n    # T칤tulo principal usando suptitle\n    fig.suptitle(f\"Barrio {barrio_nombre}\", fontsize=16, fontweight=\"bold\", y=0.98)\n\n    # Subt칤tulo usando title\n    ax.set_title(\n        f\"RENABAP: {familias_renabap} familias | Edificios detectados: {total_edificios}\",\n        fontsize=12,\n        style=\"italic\",\n        pad=30,\n    )\n\n    # Limpiar el mapa\n    ax.set_xticks([])\n    ax.set_yticks([])\n    ax.set_xlabel(\"\")\n    ax.set_ylabel(\"\")\n    ax.spines[\"top\"].set_visible(False)\n    ax.spines[\"right\"].set_visible(False)\n    ax.spines[\"bottom\"].set_visible(False)\n    ax.spines[\"left\"].set_visible(False)\n\n    plt.tight_layout()\n    plt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c)\n\n\n\n\n\n\n\n\n\n\n\n(d)\n\n\n\n\n\n\n\nFigure4.4",
    "crumbs": [
      "<span class='chapter-number'>4</span> <span class='chapter-title'>RENABAP</span>"
    ]
  },
  {
    "objectID": "renabap.html#procesamiento-y-resultados",
    "href": "renabap.html#procesamiento-y-resultados",
    "title": "4 RENABAP",
    "section": "4.6 Procesamiento y resultados",
    "text": "4.6 Procesamiento y resultados\n\n\nMostrar c칩digo\n# =============================================================================\n# EXPOSICI칍N POR BARRIO\n# =============================================================================\n# Preparar datos - solo alta y media\nexposure_data = resultado_exposicion_barrio[\n    resultado_exposicion_barrio[\"peligrosidad\"].isin([\"alta\", \"media\"])\n].copy()\n\n# Merge con geometr칤as para obtener centroides\nexposure_gdf = exposure_data.merge(\n    renabap_pba_intersect[[\"id_renabap\", \"geometry\"]], on=\"id_renabap\"\n)\nexposure_gdf = gpd.GeoDataFrame(exposure_gdf, geometry=\"geometry\", crs=USE_CRS)\n\n# Convertir a Web Mercator para el plotting\nexposure_gdf_3857 = exposure_gdf.to_crs(WEB_MERCATOR_CRS)\nla_plata_3857 = la_plata.to_crs(WEB_MERCATOR_CRS)\n\n\n# Filtrar exposici칩n alta y media por nombre de barrio (excluyendo \"Sin Nombre\")\nbarrios_alta_data = (\n    resultado_exposicion_barrio[\n        (resultado_exposicion_barrio[\"peligrosidad\"] == \"alta\")\n        & (resultado_exposicion_barrio[\"nombre_barrio\"] != \"Sin Nombre\")\n    ]\n    .groupby(\"nombre_barrio\")[\"edificios_expuestos\"]\n    .sum()\n    .reset_index()\n    .sort_values(\"edificios_expuestos\", ascending=False)\n    .head(10)\n)\n\nbarrios_media_data = (\n    resultado_exposicion_barrio[\n        (resultado_exposicion_barrio[\"peligrosidad\"] == \"media\")\n        & (resultado_exposicion_barrio[\"nombre_barrio\"] != \"Sin Nombre\")\n    ]\n    .groupby(\"nombre_barrio\")[\"edificios_expuestos\"]\n    .sum()\n    .reset_index()\n)\n\n# Merge para tener ambos niveles\nbarrios_combined = barrios_alta_data.merge(\n    barrios_media_data, on=\"nombre_barrio\", how=\"left\", suffixes=(\"_alta\", \"_media\")\n)\nbarrios_combined[\"edificios_expuestos_media\"] = barrios_combined[\n    \"edificios_expuestos_media\"\n].fillna(0)\n\n# =============================================================================\n# EXPOSICI칍N POR CUENCA Y EJE\n# =============================================================================\n\ncuenca_alta_data = (\n    resultado_exposicion_cuenca[resultado_exposicion_cuenca[\"peligrosidad\"] == \"alta\"]\n    .groupby(\"Cuenca\")[\"edificios_expuestos\"]\n    .sum()\n    .reset_index()\n    .sort_values(\"edificios_expuestos\", ascending=False)\n)\n\ncuenca_media_data = (\n    resultado_exposicion_cuenca[resultado_exposicion_cuenca[\"peligrosidad\"] == \"media\"]\n    .groupby(\"Cuenca\")[\"edificios_expuestos\"]\n    .sum()\n    .reset_index()\n)\n\n# Merge para tener ambos niveles\ncuenca_combined = cuenca_alta_data.merge(\n    cuenca_media_data, on=\"Cuenca\", how=\"left\", suffixes=(\"_alta\", \"_media\")\n)\ncuenca_combined[\"edificios_expuestos_media\"] = cuenca_combined[\n    \"edificios_expuestos_media\"\n].fillna(0)\n\n# === GR츼FICO DE EJES ===\n# Filtrar exposici칩n alta y media por eje\neje_alta_data = (\n    resultado_exposicion_eje[resultado_exposicion_eje[\"peligrosidad\"] == \"alta\"]\n    .groupby(\"eje\")[\"edificios_expuestos\"]\n    .sum()\n    .reset_index()\n    .sort_values(\"edificios_expuestos\", ascending=False)\n)\n\neje_media_data = (\n    resultado_exposicion_eje[resultado_exposicion_eje[\"peligrosidad\"] == \"media\"]\n    .groupby(\"eje\")[\"edificios_expuestos\"]\n    .sum()\n    .reset_index()\n)\n\n# Merge para tener ambos niveles\neje_combined = eje_alta_data.merge(\n    eje_media_data, on=\"eje\", how=\"left\", suffixes=(\"_alta\", \"_media\")\n)\neje_combined[\"edificios_expuestos_media\"] = eje_combined[\n    \"edificios_expuestos_media\"\n].fillna(0)\n\n# =============================================================================\n# CALCULAR ESTAD칈STICAS RESUMEN PARA EL TEXTO\n# =============================================================================\n\n# Totales de edificios expuestos (sin duplicados)\n# Los edificios que intersectan con ambos peligros ya est치n resueltos por prioridad en buildings_barrio_unique\ntotal_buildings_high_hazard = int(buildings_barrio_unique[buildings_barrio_unique[\"PELIGROSID\"] == \"alta\"].shape[0])\ntotal_buildings_medium_hazard = int(buildings_barrio_unique[buildings_barrio_unique[\"PELIGROSID\"] == \"media\"].shape[0])\ntotal_buildings_exposed = total_buildings_high_hazard + total_buildings_medium_hazard\n\n# Total de edificios en barrios\ntotal_buildings_in_barrios = len(buildings_in_barrios)\npercentage_exposed = float(round((total_buildings_exposed / total_buildings_in_barrios) * 100, 1))\n\n# Top 5 barrios por exposici칩n a peligro alto\ntop_5_barrios_alta = (\n    resultado_exposicion_barrio[\n        (resultado_exposicion_barrio[\"peligrosidad\"] == \"alta\") & \n        (resultado_exposicion_barrio[\"nombre_barrio\"] != \"Sin Nombre\")\n    ]\n    .groupby(\"nombre_barrio\")[\"edificios_expuestos\"]\n    .sum()\n    .reset_index()\n    .sort_values(\"edificios_expuestos\", ascending=False)\n    .head(5)\n    .merge(\n        buildings_with_barrios.groupby(\"nombre_barrio\").size().reset_index(name=\"total_edificios_barrio\"),\n        on=\"nombre_barrio\"\n    )\n    .assign(porcentaje=lambda x: (x[\"edificios_expuestos\"] / x[\"total_edificios_barrio\"] * 100).round(1).astype(float))\n)\n\n# Top 5 cuencas con desglose por peligrosidad usando pivot\ntop_5_cuencas = (\n    resultado_exposicion_cuenca\n    .pivot_table(\n        index=\"Cuenca\", \n        columns=\"peligrosidad\", \n        values=\"edificios_expuestos\", \n        aggfunc=\"sum\", \n        fill_value=0\n    )\n    .reset_index()\n    .assign(edificios_expuestos_total=lambda x: x[\"alta\"] + x[\"media\"])\n    .rename(columns={\"alta\": \"edificios_expuestos_alta\", \"media\": \"edificios_expuestos_media\"})\n    .merge(\n        total_edificios_cuenca, \n        on=\"Cuenca\"\n    )\n    .sort_values(\"edificios_expuestos_total\", ascending=False)\n    .head(5)\n)\n\n\nEn los barrios populares de La Plata el an치lisis realizado identifica 17.014 edificaciones o techos expuestos a peligro de inundaci칩n bajo el escenario de precipitaci칩n m치xima probable (PMP), lo que representa el 23,5% del total de edificaciones o techos en barrios populares. De ellos, 6.112 se encuentran en zonas de peligro alto y 10.902 en zonas de peligro medio.\nLa exposici칩n en barrios populares se concentra principalmente en los alrededores del casco urbano de La Plata. Villa Montoro lidera con 669 edificaciones o techos expuestos a peligro alto (21,7% del barrio), seguido por La Esperanza con 440 edificaciones (16,3%), Las Palmeras con 417 (33,7%), Toba con 335 (67,7%), y La Isla con 320 edificaciones (96,4%).\nA nivel de cuencas hidrogr치ficas, Cuenca Arroyo del Gato concentra la mayor exposici칩n con 7.943 edificaciones o techos expuestos (23,0% del total de edificaciones en barrios populares de la cuenca; 2.662 a peligro alto y 5.281 a peligro medio), principalmente debido a la presencia de Villa Montoro y otros barrios populares importantes. Le sigue Cuenca A춿 Maldonado con 3.316 edificaciones o techos (18,9% del total; 1.000 alta, 2.316 media) y Cuenca Arroyo Mart칤n-Carnaval con 1.096 edificaciones o techos (49,1% del total; 368 alta, 728 media).\n\n4.6.1 Comparaci칩n metodol칩gica\nUna comparaci칩n entre el enfoque tradicional de interpolaci칩n areal (basado en datos RENABAP) y nuestro an치lisis a nivel de edificaci칩n o techo revela diferencias significativas en las estimaciones de exposici칩n. Utilizando interpolaci칩n areal, donde se asume que las familias se distribuyen uniformemente en los barrios populares, se estima que 8.913 familias estar칤an expuestas a peligros de inundaci칩n (26,3% del total de familias seg칰n RENABAP), con 2.948 familias en zonas de peligro alto y 5.964 en zonas de peligro medio.\nEn contraste, nuestro an치lisis de edificaciones identifica 18.715 familias expuestas (23,5% del total de familias seg칰n nuestro an치lisis), representando 6.723 familias en peligro alto y 11.992 en peligro medio. Esta diferencia se debe principalmente a la identificaci칩n de aproximadamente el doble de viviendas en Barrios Populares de lo que sugieren los datos oficiales del RENABAP.\nAunque nuestro m칠todo identifica m치s familias expuestas en total, la proporci칩n de exposici칩n es menor (23,5% vs 26,3%) que con la interpolaci칩n areal anterior, demostrando que el m칠todo antiguo sobreestimaba la exposici칩n al asumir distribuci칩n uniforme de poblaci칩n. Nuestro enfoque m치s preciso espacialmente identifica m치s edificaciones pero calcula menor exposici칩n proporcional debido a su mayor exactitud. Esto resulta en estimaciones m치s confiables tanto del n칰mero total como de la ubicaci칩n espec칤fica de viviendas en zonas de peligro.\n\n\n4.6.2 Exposici칩n por barrio\n\n\nMostrar c칩digo\n# Crear el mapa\nfig, ax = plt.subplots(figsize=DEFAULT_FIGSIZE)\n\n# Configurar l칤mites\nbounds = la_plata_3857.total_bounds\nmargin = 2000  # metros\nax.set_xlim(bounds[0] - margin, bounds[2] + margin)\nax.set_ylim(bounds[1] - margin, bounds[3] + margin)\n\n# Agregar basemap de contextily\ncx.add_basemap(\n    ax, crs=WEB_MERCATOR_CRS, source=cx.providers.CartoDB.PositronNoLabels, alpha=0.7, attribution=\"Datos: RENABAP (2023), VIDA (2023) | Mapa base: Carto (2025)\"\n)\n\n# Plot de puntos con jitter\nnp.random.seed(42)\nplotting_order = [\"media\", \"alta\"]\n\nfor peligrosidad in plotting_order:\n    level_data = exposure_gdf_3857[exposure_gdf_3857[\"peligrosidad\"] == peligrosidad]\n    for _, row in level_data.iterrows():\n        centroid = row[\"geometry\"].centroid\n        jitter_x = np.random.uniform(-200, 200)\n        jitter_y = np.random.uniform(-200, 200)\n        x_pos = centroid.x + jitter_x\n        y_pos = centroid.y + jitter_y\n        color = PELIGROSIDAD_COLORS[row[\"peligrosidad\"]]\n        size = max(10, row[\"edificios_expuestos\"] * 0.5 + 15)\n        ax.scatter(\n            x_pos,\n            y_pos,\n            s=size,\n            color=color,\n            alpha=0.9,\n            edgecolors=\"white\",\n            linewidth=1.0,\n        )\n\n# Leyenda de peligrosidad\nlegend_elements_peligro = [\n    plt.Line2D(\n        [0],\n        [0],\n        marker=\"o\",\n        color=\"w\",\n        markerfacecolor=PELIGROSIDAD_COLORS[\"alta\"],\n        markersize=8,\n        label=\"Alta\",\n    ),\n    plt.Line2D(\n        [0],\n        [0],\n        marker=\"o\",\n        color=\"w\",\n        markerfacecolor=PELIGROSIDAD_COLORS[\"media\"],\n        markersize=8,\n        label=\"Media\",\n    ),\n]\n\n# Leyenda de tama침o\nbuilding_values = [100, 500, 1000]\nlegend_elements_size = []\nfor val in building_values:\n    size = max(10, val * 0.5 + 15)\n    legend_elements_size.append(\n        plt.Line2D(\n            [0],\n            [0],\n            marker=\"o\",\n            color=\"w\",\n            markerfacecolor=\"gray\",\n            markersize=np.sqrt(size / 10),\n            label=f\"{val} edificios\",\n        )\n    )\n\n# Crear leyendas lado a lado en bottom right\nlegend1 = ax.legend(\n    handles=legend_elements_peligro,\n    title=\"Nivel de peligrosidad\",\n    loc=\"lower right\",\n    bbox_to_anchor=(0.85, 0),\n)\nax.add_artist(legend1)\n\nlegend2 = ax.legend(\n    handles=legend_elements_size,\n    title=\"Edificios expuestos\",\n    loc=\"lower right\",\n    bbox_to_anchor=(1.0, 0),\n)\n\n\nadd_boundary_outline(ax, la_plata_3857)\n\n# Agregar escala y flecha norte para consistencia\nadd_scale_bar_and_north_arrow(ax, length=0.20)\n\n# Limpiar el mapa - quitar bordes, ticks, etc.\nax.set_title(\n    \"Exposici칩n de Barrios Populares por Nivel de Peligrosidad\",\n    fontsize=14,\n    fontweight=\"bold\",\n    pad=20,\n)\nax.set_axis_off()\n\nplt.tight_layout()\nplt.show()\n\n\n\n# Crear el gr치fico de barras\nfig, ax = plt.subplots(figsize=(12, 8))\nx = np.arange(len(barrios_combined))\nwidth = 0.35\n\nbars1 = ax.bar(\n    x - width / 2,\n    barrios_combined[\"edificios_expuestos_alta\"],\n    width,\n    label=\"Peligro Alto\",\n    color=PELIGROSIDAD_COLORS[\"alta\"],\n)\nbars2 = ax.bar(\n    x + width / 2,\n    barrios_combined[\"edificios_expuestos_media\"],\n    width,\n    label=\"Peligro Medio\",\n    color=PELIGROSIDAD_COLORS[\"media\"],\n)\n\nax.set_xlabel(\"Barrios\", fontsize=12)\nax.set_ylabel(\"Edificios Expuestos\", fontsize=12)\nax.set_title(\"Top 10 Barrios por Edificios Expuestos\", fontsize=14, fontweight=\"bold\")\nax.set_xticks(x)\nax.set_xticklabels(barrios_combined[\"nombre_barrio\"], rotation=45, ha=\"right\")\nax.legend(loc=\"upper right\")\n\n# Agregar valores en las barras\nfor bar in bars1:\n    height = bar.get_height()\n    if height &gt; 0:\n        ax.text(\n            bar.get_x() + bar.get_width() / 2.0,\n            height + 5,\n            f\"{int(height)}\",\n            ha=\"center\",\n            va=\"bottom\",\n            fontsize=10,\n        )\n\nfor bar in bars2:\n    height = bar.get_height()\n    if height &gt; 0:\n        ax.text(\n            bar.get_x() + bar.get_width() / 2.0,\n            height + 5,\n            f\"{int(height)}\",\n            ha=\"center\",\n            va=\"bottom\",\n            fontsize=10,\n        )\n\nplt.tight_layout()\nplt.show()\n\nshow(resultado_exposicion_barrio)\n\n\n\n\n\n\n\n\n\n\n\n(a) Mapa de exposici칩n de barrios populares por nivel de peligrosidad de inundaci칩n\n\n\n\n\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\n\n\n\n    \n    \n    \n        \n        \n        \n        \n        \n        \n        \n        \n    \n    \n   \n    \n      \n  \n        \n    \n    \n  \n        \n    \n    \n  \n        \n    \n      \n  \n        \n            \n                \n                \n            \n\n            \n                \n                \n            \n\n            \n                \n                \n            \n\n            \n                \n                \n            \n\n            \n                \n                \n            \n        \n    \n\n\n    Loading ITables v2.4.4 from the internet...\n    (need help?)\n    \n\n\n\n\n(c)\n\n\n\n\n\nFigure4.5\n\n\n\n\n\n\n4.6.3 Exposici칩n por cuenca y eje\n\nMostrar c칩digo\n# Crear gr치fico de cuencas\nfig1, ax1 = plt.subplots(figsize=DEFAULT_FIGSIZE)\nx = np.arange(len(cuenca_combined))\nwidth = 0.35\n\nbars1 = ax1.bar(\n    x - width / 2,\n    cuenca_combined[\"edificios_expuestos_alta\"],\n    width,\n    label=\"Peligro Alto\",\n    color=PELIGROSIDAD_COLORS[\"alta\"],\n)\nbars2 = ax1.bar(\n    x + width / 2,\n    cuenca_combined[\"edificios_expuestos_media\"],\n    width,\n    label=\"Peligro Medio\",\n    color=PELIGROSIDAD_COLORS[\"media\"],\n)\n\nax1.set_xlabel(\"Cuencas\", fontsize=12)\nax1.set_ylabel(\"Edificios Expuestos\", fontsize=12)\nax1.set_title(\"Cuencas por edificios Expuestas\", fontsize=14, fontweight=\"bold\")\nax1.set_xticks(x)\nax1.set_xticklabels(cuenca_combined[\"Cuenca\"], rotation=45, ha=\"right\")\nax1.legend(loc=\"upper right\")\n\n# Agregar valores en las barras\nfor bar in bars1:\n    height = bar.get_height()\n    if height &gt; 0:\n        ax1.text(\n            bar.get_x() + bar.get_width() / 2.0,\n            height + 20,\n            f\"{int(height)}\",\n            ha=\"center\",\n            va=\"bottom\",\n            fontsize=10,\n        )\n\nfor bar in bars2:\n    height = bar.get_height()\n    if height &gt; 0:\n        ax1.text(\n            bar.get_x() + bar.get_width() / 2.0,\n            height + 20,\n            f\"{int(height)}\",\n            ha=\"center\",\n            va=\"bottom\",\n            fontsize=10,\n        )\n\nplt.tight_layout()\nplt.show()\n\n\n\n# Crear gr치fico de ejes\nfig2, ax2 = plt.subplots(figsize=DEFAULT_FIGSIZE)\nx = np.arange(len(eje_combined))\nwidth = 0.35\n\nbars1 = ax2.bar(\n    x - width / 2,\n    eje_combined[\"edificios_expuestos_alta\"],\n    width,\n    label=\"Peligro Alto\",\n    color=PELIGROSIDAD_COLORS[\"alta\"],\n)\nbars2 = ax2.bar(\n    x + width / 2,\n    eje_combined[\"edificios_expuestos_media\"],\n    width,\n    label=\"Peligro Medio\",\n    color=PELIGROSIDAD_COLORS[\"media\"],\n)\n\nax2.set_xlabel(\"Ejes\", fontsize=12)\nax2.set_ylabel(\"Edificios Expuestos\", fontsize=12)\nax2.set_title(\"Ejes por edificios Expuestas\", fontsize=14, fontweight=\"bold\")\nax2.set_xticks(x)\nax2.set_xticklabels(eje_combined[\"eje\"], rotation=45, ha=\"right\")\nax2.legend(loc=\"upper right\")\n\n# Agregar valores en las barras\nfor bar in bars1:\n    height = bar.get_height()\n    if height &gt; 0:\n        ax2.text(\n            bar.get_x() + bar.get_width() / 2.0,\n            height + 10,\n            f\"{int(height)}\",\n            ha=\"center\",\n            va=\"bottom\",\n            fontsize=10,\n        )\n\nfor bar in bars2:\n    height = bar.get_height()\n    if height &gt; 0:\n        ax2.text(\n            bar.get_x() + bar.get_width() / 2.0,\n            height + 10,\n            f\"{int(height)}\",\n            ha=\"center\",\n            va=\"bottom\",\n            fontsize=10,\n        )\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Cuencas por edificios expuestas\n\n\n\n\n\n\n\n\n\n\n\n(b) Ejes por edificios expuestas\n\n\n\n\n\n\n\nFigure4.6: Exposici칩n por cuencas hidrogr치ficas y ejes territoriales\n\n\n\n\n\n4.6.4 Comparaci칩n de periodos de retorno\nLa implementaci칩n de diferentes pol칤ticas de gesti칩n de riesgo deber칤a depender de la evaluaci칩n del potencial de exposici칩n, y el escenario de PMP utilizado para el PRRI se considera que no necesariamente es el adecuado de utilizar para todas las pol칤ticas p칰blicas.\nUn ejemplo posible a estudiar, es el caso de la pol칤tica p칰blica que propone la relocalizaci칩n de viviendas en zonas de peligro alto y medio. En este an치lisis, hemos identificado diferencias significativas entre la exposici칩n de edificaciones dependiendo de si se utiliza el escenario PMP, el per칤odo de retorno de 25 a침os o el per칤odo de retorno de 100 a침os para calcular el riesgo (Carner, Ortiz, and Lacunza en edici칩n).\n\nMostrar c칩digo\n# =============================================================================\n# GRAPHICS: RETURN PERIOD COMPARISON\n# =============================================================================\n\n# Preparar datos de cuenca Maldonado para clipping\ncuenca_maldonado = cuencas[cuencas[\"Cuenca\"] == \"Cuenca A춿 Maldonado\"].copy()\n\n\n# Rutas de archivos\nr100_path = \"/home/nissim/Documents/dev/fulbright/ciut-riesgo/notebooks/data/raster verctorizados/Peligrosidad_R100_polig.shp\"\nr25_path = \"/home/nissim/Documents/dev/fulbright/ciut-riesgo/notebooks/data/raster verctorizados/Peligrosidad_R25_polig.shp\"\n\n# Color mapping para R100 y R25\ncolor_mapping = {\n    \"Medio\": PELIGROSIDAD_COLORS[\"media\"],\n    \"Alto\": PELIGROSIDAD_COLORS[\"alta\"],\n}\n\n# === MAPA PMP ===\npeligro_pmp_maldonado = gpd.clip(peligro_la_plata, cuenca_maldonado)\npeligro_pmp_maldonado = peligro_pmp_maldonado[\n    peligro_pmp_maldonado[\"PELIGROSID\"].isin([\"alta\", \"media\"])\n]\npeligro_pmp_maldonado_3857 = peligro_pmp_maldonado.to_crs(WEB_MERCATOR_CRS)\n\nfig1, ax1 = create_consistent_map(\n    \"PMP (Precipitaci칩n M치xima Probable)\", crs=USE_CRS, boundary_gdf=cuenca_maldonado, attribution=\"Datos: Romanazzi et al. (2019), DIPSOH (2025) | Mapa base: Carto (2025)\", scalebar_length=0.2\n)\npeligro_pmp_maldonado_3857.plot(\n    ax=ax1,\n    color=peligro_pmp_maldonado_3857[\"PELIGROSID\"].map(PELIGROSIDAD_COLORS),\n    alpha=0.75,\n    zorder=5,\n)\nax1.legend(handles=PELIGROSIDAD_LEGEND, loc=\"lower right\")\nplt.tight_layout()\nplt.show()\n\n# === MAPA R100 ===\npelig_100_maldonado = gpd.read_file(r100_path).to_crs(USE_CRS)\npelig_100_maldonado = pelig_100_maldonado[\n    pelig_100_maldonado[\"peli\"].isin([\"Alto\", \"Medio\"])\n]\npelig_100_maldonado_clipped_3857 = gpd.clip(\n    pelig_100_maldonado, cuenca_maldonado\n).to_crs(WEB_MERCATOR_CRS)\n\nfig2, ax2 = create_consistent_map(\n    \"R100 (Per칤odo de retorno 100 a침os)\", crs=USE_CRS, boundary_gdf=cuenca_maldonado, attribution=\"Datos: Carner et al. (en edici칩n), DIPSOH (2025) | Mapa base: Carto (2025)\", scalebar_length=0.2\n)\npelig_100_maldonado_clipped_3857.plot(\n    ax=ax2,\n    color=pelig_100_maldonado_clipped_3857[\"peli\"].map(color_mapping),\n    alpha=0.75,\n    zorder=5,\n)\nax2.legend(handles=PELIGROSIDAD_LEGEND, loc=\"lower right\")\nplt.tight_layout()\nplt.show()\n\n# === MAPA R25 ===\npelig_25_maldonado = gpd.read_file(r25_path).to_crs(USE_CRS)\npelig_25_maldonado = pelig_25_maldonado[\n    pelig_25_maldonado[\"peli\"].isin([\"Alto\", \"Medio\"])\n]\npelig_25_maldonado_clipped_3857 = gpd.clip(pelig_25_maldonado, cuenca_maldonado).to_crs(\n    WEB_MERCATOR_CRS\n)\n\nfig3, ax3 = create_consistent_map(\n    \"R25 (Per칤odo de retorno 25 a침os)\", crs=USE_CRS, boundary_gdf=cuenca_maldonado, attribution=\"Datos: Carner et al. (en edici칩n), DIPSOH (2025) | Mapa base: Carto (2025)\", scalebar_length=0.2\n)\npelig_25_maldonado_clipped_3857.plot(\n    ax=ax3,\n    color=pelig_25_maldonado_clipped_3857[\"peli\"].map(color_mapping),\n    alpha=0.75,\n    zorder=5,\n)\nax3.legend(handles=PELIGROSIDAD_LEGEND, loc=\"lower right\")\nplt.tight_layout()\nplt.show()\n\n\n# =============================================================================\n# ANALYTICAL PROCESSING: RETURN PERIOD DATA\n# =============================================================================\n\n# Helper function para procesar datos de peligro\ndef process_hazard_data(file_path, buildings):\n    pelig_data = gpd.read_file(file_path).to_crs(USE_CRS)\n    pelig_filtered = pelig_data[pelig_data[\"peli\"].isin([\"Alto\", \"Medio\"])].copy()\n    pelig_simple = pelig_filtered.dissolve(by=\"peli\").reset_index()\n\n    buildings_with_peligro = gpd.sjoin(\n        buildings, pelig_simple[[\"peli\", \"geometry\"]], how=\"left\", predicate=\"within\"\n    )\n    buildings_exposed = buildings_with_peligro.dropna(subset=[\"peli\"]).copy()\n\n    hazard_priority = {\"Alto\": 3, \"Medio\": 2}\n    buildings_exposed.loc[:, \"prioridad\"] = buildings_exposed[\"peli\"].map(\n        hazard_priority\n    )\n    buildings_unique = buildings_exposed.sort_values(\n        \"prioridad\", ascending=False\n    ).drop_duplicates(subset=buildings_exposed.geometry.name, keep=\"first\")\n\n    exposicion = (\n        buildings_unique.groupby(\"peli\").size().reset_index(name=\"edificios_expuestos\")\n    )\n    result = {}\n    for _, row in exposicion.iterrows():\n        peligro_name = \"alta\" if row[\"peli\"] == \"Alto\" else \"media\"\n        result[peligro_name] = row[\"edificios_expuestos\"]\n    return result\n\n\nbuildings_maldonado = buildings_with_barrios.copy()\n\n# === DATOS DE LOS TRES ESCENARIOS ===\n# PMP\nmaldonado_pmp = resultado_exposicion_cuenca[\n    resultado_exposicion_cuenca[\"Cuenca\"] == \"Cuenca A춿 Maldonado\"\n].copy()\npmp_data = (\n    {\n        row[\"peligrosidad\"]: int(row[\"edificios_expuestos\"])\n        for _, row in maldonado_pmp.iterrows()\n    }\n    if len(maldonado_pmp) &gt; 0\n    else {}\n)\n\n# R25 y R100\nr25_data = process_hazard_data(r25_path, buildings_maldonado)\nr100_data = process_hazard_data(r100_path, buildings_maldonado)\n\n# =============================================================================\n# GRAPHICS: FINAL COMPARISON VISUALIZATION\n# =============================================================================\n\n# === VISUALIZACI칍N COMPARATIVA ===\nescenarios = [\"PMP\", \"R100\", \"R25\"]\nalta_values = [\n    pmp_data.get(\"alta\", 0),\n    r100_data.get(\"alta\", 0),\n    r25_data.get(\"alta\", 0),\n]\nmedia_values = [\n    pmp_data.get(\"media\", 0),\n    r100_data.get(\"media\", 0),\n    r25_data.get(\"media\", 0),\n]\n\n\n\n\n\n\n\n\n\n\n\n\n(a) PMP (Precipitaci칩n M치xima Probable)\n\n\n\n\n\n\n\n\n\n\n\n(b) R100 (Per칤odo de retorno 100 a침os)\n\n\n\n\n\n\n\n\n\n\n\n(c) R25 (Per칤odo de retorno 25 a침os)\n\n\n\n\n\n\n\nFigure4.7: Escenarios de peligrosidad en Cuenca Maldonado\n\n\n\nNuestro an치lisis de exposici칩n a nivel de edificaciones o techos en la Cuenca Maldonado bajo los diversos per칤odos de retorno, muestra el impacto del per칤odo de retorno elegido sobre la poblaci칩n expuesta calculada. Bajo el escenario de PMP, observamos 1.000 edificaciones expuestas a peligro alto y 2.316 edificaciones expuestas a peligro medio. Mientras que con un per칤odo de retorno de 100 a침os, encontramos 141 edificaciones en peligro alto y 313 en peligro medio, y ante un per칤odo de retorno de 25 a침os se identifican 77 edificaciones en peligro alto y 198 en peligro medio. En t칠rminos comparativos, la exposici칩n para peligro alto frente al escenario de recurrencia de la PMP es 7.1 veces mayor en relaci칩n con una recurrencia R100 y 13.0 veces mayor frente a una recurrencia R25.\n\n\nMostrar c칩digo\nx = np.arange(len(escenarios))\nwidth = 0.35\n\nfig, ax = plt.subplots(figsize=(10, 6))\nbars1 = ax.bar(\n    x - width / 2,\n    alta_values,\n    width,\n    label=\"Peligro Alto\",\n    color=PELIGROSIDAD_COLORS[\"alta\"],\n)\nbars2 = ax.bar(\n    x + width / 2,\n    media_values,\n    width,\n    label=\"Peligro Medio\",\n    color=PELIGROSIDAD_COLORS[\"media\"],\n)\n\nax.set_xlabel(\"Escenario de Precipitaci칩n\", fontsize=12)\nax.set_ylabel(\"Edificios Expuestos\", fontsize=12)\nax.set_title(\n    \"Exposici칩n en Cuenca Maldonado por Escenario de Precipitaci칩n\",\n    fontsize=14,\n    fontweight=\"bold\",\n)\nax.set_xticks(x)\nax.set_xticklabels(escenarios)\nax.legend(loc=\"upper right\")\n\n\ndef add_value_labels(bars):\n    for bar in bars:\n        height = bar.get_height()\n        if height &gt; 0:\n            ax.text(\n                bar.get_x() + bar.get_width() / 2.0,\n                height + 20,\n                f\"{int(height)}\",\n                ha=\"center\",\n                va=\"bottom\",\n                fontsize=10,\n            )\n\n\nadd_value_labels(bars1)\nadd_value_labels(bars2)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\nCarner, Jos칠 Luis, Facundo Ortiz, and Esteban Lacunza. en edici칩n. Inundaciones y Resiliencia En Territorios Urbanos Fragmentados. Cuenca Del Arroyo Maldonado. La Plata, Argentina. In, edited by Juan Carlos Etulain. La Plata, Argentina: Editorial UNLP.\n\n\nDivisi칩n Provincial de Hidr치ulica - Provincia de Buenos Aires. 2025. Cuencas Hidrogr치ficas de La Provincia de Buenos Aires. https://www.minfra.gba.gob.ar/sig_hidraulica/geoserver/dipsoh/wfs.\n\n\nEtula칤n, Juan Carlos, dir. 2023. Construyendo Resiliencia. Modelizacion Hidrol칩gica y Elaboraci칩n Socio-Ambiental de Medidas NO Estructurales. Caso: Cuenca Del Arroyo Maldonado. Partido de La Plata. Argentina. Universidad Nacional de La Plata. Centro de Investigaciones Urbanas y Territoriales (CIUT). https://ciut.fau.unlp.edu.ar/investigacion/proyectos-en-ejecucion/.\n\n\nInstituto Geogr치fico Nacional. 2025. Divisi칩n Pol칤tico Administrativa de Tercer Orden Que Incluye Comunas, Juntas Vecinales y Dem치s Formas de Gobiernos. https://wms.ign.gob.ar/geoserver/ign/ows?version=1.0.0.\n\n\nRomanazzi, Pablo et al. 2019. Plan de Reducci칩n Del Riesgo Por Inundaciones En La Regi칩n de La Plata. Edited by Sebasti치n Guerrini, Pablo Morosi, Eduardo Pablo Spinelli, and Josefina L칩pez MacKenzie. 1st ed. La Plata: Universidad Nacional de La Plata. Facultad de Ingenier칤a; Municipalidad de La Plata. https://sedici.unlp.edu.ar/bitstream/handle/10915/165109/Documento_completo.pdf-PDFA.pdf?sequence=1&isAllowed=y.\n\n\nRomanazzi, Pablo Gustavo, Lucas Mena, and Stefan칤a Valinoti. 2023. Plan de Reducci칩n Del Riesgo Por Inundaci칩n Para La Regi칩n de La Plata (Etapa 2): Protocolos Barriales - Versi칩n 2023. In. La Plata, Argentina: Universidad Nacional de La Plata. Facultad de Ingenier칤a; Municipalidad de La Plata; Universidad Nacional de La Plata. Facultad de Humanidades y Ciencias de la Educaci칩n. https://repositoriosdigitales.mincyt.gob.ar/vufind/Record/SEDICI_ef9555f5bdb342e7f5f7d7f0f3077a2f.\n\n\nSmith, A., P. D. Bates, O. Wing, et al. 2019. New Estimates of Flood Exposure in Developing Countries Using High-Resolution Population Data. Nature Communications 10: 1814. https://doi.org/10.1038/s41467-019-09282-y.\n\n\nVIDA. 2023. Google-Microsoft-OSM Open Buildings - Combined by VIDA. https://source.coop/repositories/vida/google-microsoft-osm-open-buildings/access.",
    "crumbs": [
      "<span class='chapter-number'>4</span> <span class='chapter-title'>RENABAP</span>"
    ]
  },
  {
    "objectID": "renabap.html#comparativa-de-periodos-de-retorno",
    "href": "renabap.html#comparativa-de-periodos-de-retorno",
    "title": "3 RENABAP",
    "section": "3.7 Comparativa de periodos de retorno",
    "text": "3.7 Comparativa de periodos de retorno\nLa implementaci칩n de diferentes pol칤ticas de gesti칩n de riesgo depende de la evaluaci칩n del potencial de exposici칩n, y el escenario de precipitaci칩n m치xima probable (PMP) se utiliza como el m치ximo probable de precipitaci칩n para los c치lculos del modelo hidrol칩gico que requieren priorizaci칩n. Para pol칤ticas que requieren priorizaci칩n, como la relocalizaci칩n de residentes en asentamientos informales, es importante elegir un per칤odo de retorno que sea apropiado para la pol칤tica que se est치 considerando. En este an치lisis, hemos mostrado diferencias significativas entre la exposici칩n de edificios dependiendo de si se utiliza el escenario PMP, el per칤odo de retorno de 25 a침os, o el per칤odo de retorno de 100 a침os para calcular el riesgo.\n\nMostrar c칩digo\n# =============================================================================\n# GRAPHICS: RETURN PERIOD COMPARISON\n# =============================================================================\n\n# Preparar datos de cuenca Maldonado para clipping\ncuenca_maldonado = cuencas[cuencas[\"Cuenca\"] == \"Cuenca A춿 Maldonado\"].copy()\n\n\n# Rutas de archivos\nr100_path = \"/home/nissim/Documents/dev/fulbright/ciut-riesgo/notebooks/data/raster verctorizados/Peligrosidad_R100_polig.shp\"\nr25_path = \"/home/nissim/Documents/dev/fulbright/ciut-riesgo/notebooks/data/raster verctorizados/Peligrosidad_R25_polig.shp\"\n\n# Color mapping para R100 y R25\ncolor_mapping = {\n    \"Medio\": PELIGROSIDAD_COLORS[\"media\"],\n    \"Alto\": PELIGROSIDAD_COLORS[\"alta\"],\n}\n\n# === MAPA PMP ===\npeligro_pmp_maldonado = gpd.clip(peligro_la_plata, cuenca_maldonado)\npeligro_pmp_maldonado = peligro_pmp_maldonado[\n    peligro_pmp_maldonado[\"PELIGROSID\"].isin([\"alta\", \"media\"])\n]\npeligro_pmp_maldonado_3857 = peligro_pmp_maldonado.to_crs(WEB_MERCATOR_CRS)\n\nfig1, ax1 = create_consistent_map(\n    \"PMP (Precipitaci칩n M치xima Probable)\", crs=USE_CRS, boundary_gdf=cuenca_maldonado, attribution=\"Datos: Etula칤n et al. (en prensa), DIPSOH (2025) | Mapa base: Carto (2025)\", scalebar_length=0.2\n)\npeligro_pmp_maldonado_3857.plot(\n    ax=ax1,\n    color=peligro_pmp_maldonado_3857[\"PELIGROSID\"].map(PELIGROSIDAD_COLORS),\n    alpha=0.75,\n    zorder=5,\n)\nax1.legend(handles=PELIGROSIDAD_LEGEND, loc=\"lower right\")\nplt.tight_layout()\nplt.show()\n\n# === MAPA R100 ===\npelig_100_maldonado = gpd.read_file(r100_path).to_crs(USE_CRS)\npelig_100_maldonado = pelig_100_maldonado[\n    pelig_100_maldonado[\"peli\"].isin([\"Alto\", \"Medio\"])\n]\npelig_100_maldonado_clipped_3857 = gpd.clip(\n    pelig_100_maldonado, cuenca_maldonado\n).to_crs(WEB_MERCATOR_CRS)\n\nfig2, ax2 = create_consistent_map(\n    \"R100 (Per칤odo de retorno 100 a침os)\", crs=USE_CRS, boundary_gdf=cuenca_maldonado, attribution=\"Datos: Etula칤n et al. (en prensa), DIPSOH (2025) | Mapa base: Carto (2025)\", scalebar_length=0.2\n)\npelig_100_maldonado_clipped_3857.plot(\n    ax=ax2,\n    color=pelig_100_maldonado_clipped_3857[\"peli\"].map(color_mapping),\n    alpha=0.75,\n    zorder=5,\n)\nax2.legend(handles=PELIGROSIDAD_LEGEND, loc=\"lower right\")\nplt.tight_layout()\nplt.show()\n\n# === MAPA R25 ===\npelig_25_maldonado = gpd.read_file(r25_path).to_crs(USE_CRS)\npelig_25_maldonado = pelig_25_maldonado[\n    pelig_25_maldonado[\"peli\"].isin([\"Alto\", \"Medio\"])\n]\npelig_25_maldonado_clipped_3857 = gpd.clip(pelig_25_maldonado, cuenca_maldonado).to_crs(\n    WEB_MERCATOR_CRS\n)\n\nfig3, ax3 = create_consistent_map(\n    \"R25 (Per칤odo de retorno 25 a침os)\", crs=USE_CRS, boundary_gdf=cuenca_maldonado, attribution=\"Datos: Etula칤n et al. (en prensa), DIPSOH (2025) | Mapa base: Carto (2025)\", scalebar_length=0.2\n)\npelig_25_maldonado_clipped_3857.plot(\n    ax=ax3,\n    color=pelig_25_maldonado_clipped_3857[\"peli\"].map(color_mapping),\n    alpha=0.75,\n    zorder=5,\n)\nax3.legend(handles=PELIGROSIDAD_LEGEND, loc=\"lower right\")\nplt.tight_layout()\nplt.show()\n\n\n# =============================================================================\n# ANALYTICAL PROCESSING: RETURN PERIOD DATA\n# =============================================================================\n\n# Helper function para procesar datos de peligro\ndef process_hazard_data(file_path, buildings):\n    pelig_data = gpd.read_file(file_path).to_crs(USE_CRS)\n    pelig_filtered = pelig_data[pelig_data[\"peli\"].isin([\"Alto\", \"Medio\"])].copy()\n    pelig_simple = pelig_filtered.dissolve(by=\"peli\").reset_index()\n\n    buildings_with_peligro = gpd.sjoin(\n        buildings, pelig_simple[[\"peli\", \"geometry\"]], how=\"left\", predicate=\"within\"\n    )\n    buildings_exposed = buildings_with_peligro.dropna(subset=[\"peli\"]).copy()\n\n    hazard_priority = {\"Alto\": 3, \"Medio\": 2}\n    buildings_exposed.loc[:, \"prioridad\"] = buildings_exposed[\"peli\"].map(\n        hazard_priority\n    )\n    buildings_unique = buildings_exposed.sort_values(\n        \"prioridad\", ascending=False\n    ).drop_duplicates(subset=buildings_exposed.geometry.name, keep=\"first\")\n\n    exposicion = (\n        buildings_unique.groupby(\"peli\").size().reset_index(name=\"edificios_expuestos\")\n    )\n    result = {}\n    for _, row in exposicion.iterrows():\n        peligro_name = \"alta\" if row[\"peli\"] == \"Alto\" else \"media\"\n        result[peligro_name] = row[\"edificios_expuestos\"]\n    return result\n\n\nbuildings_maldonado = buildings_with_barrios.copy()\n\n# === DATOS DE LOS TRES ESCENARIOS ===\n# PMP\nmaldonado_pmp = resultado_exposicion_cuenca[\n    resultado_exposicion_cuenca[\"Cuenca\"] == \"Cuenca A춿 Maldonado\"\n].copy()\npmp_data = (\n    {\n        row[\"peligrosidad\"]: int(row[\"edificios_expuestos\"])\n        for _, row in maldonado_pmp.iterrows()\n    }\n    if len(maldonado_pmp) &gt; 0\n    else {}\n)\n\n# R25 y R100\nr25_data = process_hazard_data(r25_path, buildings_maldonado)\nr100_data = process_hazard_data(r100_path, buildings_maldonado)\n\n# =============================================================================\n# GRAPHICS: FINAL COMPARISON VISUALIZATION\n# =============================================================================\n\n# === VISUALIZACI칍N COMPARATIVA ===\nescenarios = [\"PMP\", \"R100\", \"R25\"]\nalta_values = [\n    pmp_data.get(\"alta\", 0),\n    r100_data.get(\"alta\", 0),\n    r25_data.get(\"alta\", 0),\n]\nmedia_values = [\n    pmp_data.get(\"media\", 0),\n    r100_data.get(\"media\", 0),\n    r25_data.get(\"media\", 0),\n]\n\n\n\n\n\n\n\n\n\n\n\n\n(a) PMP (Precipitaci칩n M치xima Probable)\n\n\n\n\n\n\n\n\n\n\n\n(b) R100 (Per칤odo de retorno 100 a침os)\n\n\n\n\n\n\n\n\n\n\n\n(c) R25 (Per칤odo de retorno 25 a침os)\n\n\n\n\n\n\n\nFigure3.7: Escenarios de peligrosidad en Cuenca Maldonado\n\n\n\nNuestro an치lisis de exposici칩n a nivel de edificio en la Cuenca Maldonado bajo los diversos per칤odos de retorno muestra el impacto del per칤odo de retorno elegido sobre la poblaci칩n expuesta calculada. Bajo el escenario de precipitaci칩n m치xima probable (PMP), observamos 1.000 edificios expuestos a peligro alto y 2.316 edificios expuestos a peligro medio, mientras que bajo el per칤odo de retorno de 100 a침os encontramos 141 edificios en peligro alto y 313 en peligro medio, y bajo el per칤odo de retorno de 25 a침os se identifican 77 edificios en peligro alto y 198 en peligro medio.\nEn t칠rminos comparativos, la exposici칩n bajo PMP es 7.1 veces mayor que bajo R100 para peligro alto y 7.4 veces mayor para peligro medio. Comparando PMP con R25, la exposici칩n es 13.0 veces mayor para peligro alto y 11.7 veces mayor para peligro medio. Incluso entre R100 y R25, la exposici칩n es 1.8 veces mayor para peligro alto y 1.6 veces mayor para peligro medio. Estos resultados demuestran las diferencias significativas en las estimaciones de exposici칩n que resultan de la elecci칩n del per칤odo de retorno para el c치lculo del riesgo.\n\n\nMostrar c칩digo\nx = np.arange(len(escenarios))\nwidth = 0.35\n\nfig, ax = plt.subplots(figsize=(10, 6))\nbars1 = ax.bar(\n    x - width / 2,\n    alta_values,\n    width,\n    label=\"Peligro Alto\",\n    color=PELIGROSIDAD_COLORS[\"alta\"],\n)\nbars2 = ax.bar(\n    x + width / 2,\n    media_values,\n    width,\n    label=\"Peligro Medio\",\n    color=PELIGROSIDAD_COLORS[\"media\"],\n)\n\nax.set_xlabel(\"Escenario de Precipitaci칩n\", fontsize=12)\nax.set_ylabel(\"Edificios Expuestos\", fontsize=12)\nax.set_title(\n    \"Exposici칩n en Cuenca Maldonado por Escenario de Precipitaci칩n\",\n    fontsize=14,\n    fontweight=\"bold\",\n)\nax.set_xticks(x)\nax.set_xticklabels(escenarios)\nax.legend(loc=\"upper right\")\n\n\ndef add_value_labels(bars):\n    for bar in bars:\n        height = bar.get_height()\n        if height &gt; 0:\n            ax.text(\n                bar.get_x() + bar.get_width() / 2.0,\n                height + 20,\n                f\"{int(height)}\",\n                ha=\"center\",\n                va=\"bottom\",\n                fontsize=10,\n            )\n\n\nadd_value_labels(bars1)\nadd_value_labels(bars2)\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>3</span> <span class='chapter-title'>RENABAP</span>"
    ]
  },
  {
    "objectID": "renabap.html#conclusiones",
    "href": "renabap.html#conclusiones",
    "title": "4 RENABAP",
    "section": "4.7 Conclusiones",
    "text": "4.7 Conclusiones\nLos datos de huellas de edificaciones nos permiten realizar evaluaciones mucho m치s precisas de la exposici칩n en barrios populares en todo el partido y revelan una subestimaci칩n cr칤tica en los datos oficiales. Este an치lisis identifica aproximadamente 41.575 edificaciones o techos faltantes que no est치n contabilizadas en los datos del RENABAP, lo que representa potencialmente entre 137.197 y 228.662 personas no contabilizadas en los barrios populares (usando un rango razonable de 3 a 5 personas por vivienda). Esta discrepancia tiene implicaciones profundas para la planificaci칩n de la gesti칩n del riesgo y la asignaci칩n de recursos.\nEn los barrios populares de La Plata se identifican 17.014 edificaciones expuestas a peligro de inundaci칩n ante el escenario de PMP, lo que representa el 23,5% del total de edificaciones en barrios populares. De estas, 6.112 edificaciones se encuentran en zonas de peligro alto y 10.902 en zonas de peligro medio. La exposici칩n se concentra principalmente en los alrededores del casco urbano de La Plata. Villa Montoro lidera con 669 edificaciones expuestas a peligro alto (21,7% del barrio), seguido por La Esperanza con 440 edificaciones (16,3%), Las Palmeras con 417 (33,7%), Toba con 335 (67,7%), y La Isla con 320 edificaciones (96,4%). A nivel de cuencas hidrogr치ficas, Cuenca Arroyo del Gato concentra la mayor exposici칩n con 7.943 edificaciones expuestas (2.662 a peligro alto y 5.281 a peligro medio), principalmente debido a la presencia de Villa Montoro y otros asentamientos importantes. Le sigue Cuenca A춿 Maldonado con 3.316 edificaciones (1.000 alta, 2.316 media) y Cuenca Arroyo Mart칤n-Carnaval con 1.096 edificaciones (368 alta, 728 media).\nAdem치s, el an치lisis comparativo de tasas de exposici칩n de edificaciones para la Cuenca Maldonado bajo diferentes per칤odos de retorno, incluyendo la PMP utilizada en el resto del estudio versus per칤odos de retorno de 100 a침os y 25 a침os (Etula칤n 2023), revela que la elecci칩n del per칤odo de retorno genera diferencias significativas en las tasas de exposici칩n. Encontramos que bajo la PMP se exponen m치s edificaciones en un que bajo los per칤odos de retorno de 25 y 100 a침os, lo cual es fundamental considerar al determinar qu칠 치reas priorizar para la reubicaci칩n de residentes en barrios populares. En t칠rminos comparativos, la exposici칩n para peligro alto frente al escenario de recurrencia de la PMP es 7.1 veces mayor en relaci칩n con una recurrencia R100 para peligro alto y 7.4 veces mayor para peligro medio. Comparando PMP con R25, la exposici칩n es 13.0 veces mayor frente a una recurrencia R25.\nLa comparaci칩n metodol칩gica entre interpolaci칩n areal y an치lisis a nivel de edificaciones o techo demuestra que nuestro enfoque m치s comprehensivo y preciso aporta un mayor n칰mero total de poblaci칩n expuesta (debido a la identificaci칩n de aproximadamente el doble de edificaciones que los datos oficiales del RENABAP), pero una menor proporci칩n de exposici칩n relativa (23,5% vs 26,3%), lo que demuestra que la interpolaci칩n areal sobrestima la exposici칩n relativa al asumir una distribuci칩n uniforme de la poblaci칩n. Esta mayor precisi칩n espacial que no asume distribuci칩n uniforme, hace que nuestro m칠todo sea m치s confiable para la evaluaci칩n de riesgos frente a inundaciones.\nEste enfoque basado en edificaciones no solo proporciona estimaciones m치s precisas y actualizadas que los m칠todos tradicionales de interpolaci칩n areal, sino que tambi칠n demuestra la necesidad urgente de actualizar los registros oficiales de barrios populares. Los datos globales de huellas de edificaciones representan una herramienta esencial para comprender la verdadera magnitud de la poblaci칩n en riesgo y para la planificaci칩n efectiva de pol칤ticas p칰blicas de diversa naturaleza.\n\n\n\n\nCarner, Jos칠 Luis, Facundo Ortiz, and Esteban Lacunza. en edici칩n. Inundaciones y Resiliencia En Territorios Urbanos Fragmentados. Cuenca Del Arroyo Maldonado. La Plata, Argentina. In, edited by Juan Carlos Etulain. La Plata, Argentina: Editorial UNLP.\n\n\nDivisi칩n Provincial de Hidr치ulica - Provincia de Buenos Aires. 2025. Cuencas Hidrogr치ficas de La Provincia de Buenos Aires. https://www.minfra.gba.gob.ar/sig_hidraulica/geoserver/dipsoh/wfs.\n\n\nEtula칤n, Juan Carlos, dir. 2023. Construyendo Resiliencia. Modelizacion Hidrol칩gica y Elaboraci칩n Socio-Ambiental de Medidas NO Estructurales. Caso: Cuenca Del Arroyo Maldonado. Partido de La Plata. Argentina. Universidad Nacional de La Plata. Centro de Investigaciones Urbanas y Territoriales (CIUT). https://ciut.fau.unlp.edu.ar/investigacion/proyectos-en-ejecucion/.\n\n\nInstituto Geogr치fico Nacional. 2025. Divisi칩n Pol칤tico Administrativa de Tercer Orden Que Incluye Comunas, Juntas Vecinales y Dem치s Formas de Gobiernos. https://wms.ign.gob.ar/geoserver/ign/ows?version=1.0.0.\n\n\nRomanazzi, Pablo et al. 2019. Plan de Reducci칩n Del Riesgo Por Inundaciones En La Regi칩n de La Plata. Edited by Sebasti치n Guerrini, Pablo Morosi, Eduardo Pablo Spinelli, and Josefina L칩pez MacKenzie. 1st ed. La Plata: Universidad Nacional de La Plata. Facultad de Ingenier칤a; Municipalidad de La Plata. https://sedici.unlp.edu.ar/bitstream/handle/10915/165109/Documento_completo.pdf-PDFA.pdf?sequence=1&isAllowed=y.\n\n\nRomanazzi, Pablo Gustavo, Lucas Mena, and Stefan칤a Valinoti. 2023. Plan de Reducci칩n Del Riesgo Por Inundaci칩n Para La Regi칩n de La Plata (Etapa 2): Protocolos Barriales - Versi칩n 2023. In. La Plata, Argentina: Universidad Nacional de La Plata. Facultad de Ingenier칤a; Municipalidad de La Plata; Universidad Nacional de La Plata. Facultad de Humanidades y Ciencias de la Educaci칩n. https://repositoriosdigitales.mincyt.gob.ar/vufind/Record/SEDICI_ef9555f5bdb342e7f5f7d7f0f3077a2f.\n\n\nSmith, A., P. D. Bates, O. Wing, et al. 2019. New Estimates of Flood Exposure in Developing Countries Using High-Resolution Population Data. Nature Communications 10: 1814. https://doi.org/10.1038/s41467-019-09282-y.\n\n\nVIDA. 2023. Google-Microsoft-OSM Open Buildings - Combined by VIDA. https://source.coop/repositories/vida/google-microsoft-osm-open-buildings/access.",
    "crumbs": [
      "<span class='chapter-number'>4</span> <span class='chapter-title'>RENABAP</span>"
    ]
  },
  {
    "objectID": "exposicion.html",
    "href": "exposicion.html",
    "title": "1 Exposici칩n",
    "section": "",
    "text": "1.1 Introducion\nEn este flujo de trabajo aplicamos mapeo dasim칠trico para redistribuir proporcionalmente datos censales argentinos de 2022 desde el nivel de radio censal hasta una resoluci칩n de 100 metros para la localidad de Esperanza en la provincia de Santa Fe, Argentina, utilizando datos auxiliares de la Capa Global de Asentamientos Humanos (GHSL) de 2023. Este m칠todo representa una forma razonablemente efectiva de reducir la escala de datos censales a mayor resoluci칩n para su uso en modelado de riesgo clim치tico con fuentes de datos abiertos.\nMostrar c칩digo\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport rasterstats\nfrom rasterio.features import rasterize\nfrom io import BytesIO\nfrom owslib.wfs import WebFeatureService\n\nimport rioxarray\nimport contextily as ctx\nfrom shapely.geometry import box\nimport xarray as xr\n\n\nUSE_CRS = \"EPSG:5347\"  # posgar para esperanza\nWEB_MERCATOR_CRS = \"EPSG:3857\"\n\nDEFAULT_FIGSIZE = (12, 10)\nMAP_PADDING = 500\nPLASMA_CMAP = plt.cm.plasma\n\n\ndef setup_base_map(\n    figsize=None, bounds=None, boundary_gdf=None, padding_x=None, padding_y=None\n):\n    \"\"\"Create figure and set up basic map boundaries with padding.\"\"\"\n    if figsize is None:\n        figsize = DEFAULT_FIGSIZE\n    if padding_x is None:\n        padding_x = MAP_PADDING\n    if padding_y is None:\n        padding_y = MAP_PADDING\n\n    if bounds is None and boundary_gdf is not None:\n        bounds = boundary_gdf.total_bounds\n\n    # Convert bounds to Web Mercator for basemap compatibility\n    if bounds is not None:\n        # Create a temporary GeoDataFrame with the bounds to reproject\n        temp_bounds = gpd.GeoDataFrame(\n            geometry=[box(bounds[0], bounds[1], bounds[2], bounds[3])], crs=USE_CRS\n        )\n        bounds_3857 = temp_bounds.to_crs(WEB_MERCATOR_CRS).total_bounds\n    else:\n        bounds_3857 = bounds\n\n    fig, ax = plt.subplots(figsize=figsize)\n    ax.set_xlim(bounds_3857[0] - padding_x, bounds_3857[2] + padding_x)\n    ax.set_ylim(bounds_3857[1] - padding_y, bounds_3857[3] + padding_y)\n    return fig, ax\n\n\ndef add_basemap(ax, zoom=13):\n    \"\"\"Add CartoDB basemap to the axes.\"\"\"\n\n    ctx.add_basemap(\n        ax,\n        source=ctx.providers.CartoDB.PositronNoLabels,\n        zorder=0,\n        zoom=zoom,\n    )\n\n    return ax\n\n\ndef add_north_arrow(ax, x=0.95, y=0.05, arrow_length=0.04):\n    \"\"\"Add a north arrow to the map.\"\"\"\n    ax.annotate(\n        \"N\",\n        xy=(x, y),\n        xytext=(x, y - arrow_length),\n        arrowprops=dict(facecolor=\"black\", width=3, headwidth=10),\n        ha=\"center\",\n        va=\"center\",\n        fontsize=14,\n        xycoords=ax.transAxes,\n    )\n\n\ndef add_boundary_outline(ax, boundary_gdf, crs=\"EPSG:3857\"):\n    \"\"\"Add the outline of a boundary geodataframe to a map.\"\"\"\n    boundary_3857 = boundary_gdf.to_crs(crs)\n    boundary_3857.plot(\n        ax=ax,\n        facecolor=\"none\",\n        edgecolor=\"black\",\n        linewidth=0.5,\n        linestyle=\"--\",\n        legend=False,\n        zorder=5,\n    )\n\n\ndef create_consistent_map(title, boundary_gdf, bounds=None):\n    \"\"\"Create a map with consistent styling and basemap.\"\"\"\n    fig, ax = setup_base_map(bounds=bounds, boundary_gdf=boundary_gdf)\n\n    add_basemap(ax)\n\n    add_north_arrow(ax)\n\n    add_boundary_outline(ax, boundary_gdf)\n\n    ax.set_title(title, fontsize=16, fontweight=\"bold\", pad=20)\n\n    ax.set_axis_off()\n\n    return fig, ax\n\n\ndef wfs_to_gdf(\n    wfs_url: str, layer_name: str, srs: str = \"EPSG:4326\"\n) -&gt; gpd.GeoDataFrame:\n    \"\"\"\n    Descarga una capa WFS y la devuelve como GeoDataFrame.\n\n    Args:\n        wfs_url (str): URL del servicio WFS.\n        layer_name (str): Nombre de la capa (typename).\n        srs (str): C칩digo EPSG del sistema de referencia de coordenadas.\n\n    Returns:\n        gpd.GeoDataFrame: Capa descargada como GeoDataFrame.\n    \"\"\"\n    wfs = WebFeatureService(url=wfs_url, version=\"2.0.0\")\n    response = wfs.getfeature(typename=layer_name, srsname=srs)\n    gdf = gpd.read_file(BytesIO(response.read()))\n    return gdf\n\n\nbase_url = \"https://wms.ign.gob.ar/geoserver/ign/ows\"\n\nmunis = wfs_to_gdf(wfs_url=base_url, layer_name=\"ign:municipio\", srs=\"EPSG:4326\")\n\nesperanza = munis[munis[\"nam\"] == \"Esperanza\"]\nesperanza = esperanza.to_crs(USE_CRS)",
    "crumbs": [
      "<span class='chapter-number'>1</span> <span class='chapter-title'>Exposici칩n</span>"
    ]
  },
  {
    "objectID": "exposicion.html#qu칠-es-el-mapeo-dasim칠trico",
    "href": "exposicion.html#qu칠-es-el-mapeo-dasim칠trico",
    "title": "1 Exposici칩n",
    "section": "1.2 Qu칠 es el mapeo dasim칠trico?",
    "text": "1.2 Qu칠 es el mapeo dasim칠trico?\nEl mapeo dasim칠trico reorganiza datos cartogr치ficos de una unidad de recolecci칩n en 치reas m치s precisas, modificando los l칤mites originales usando datos de apoyo relacionados. Por ejemplo, un atributo de poblaci칩n organizado por tracto censal se vuelve m치s significativo cuando se eliminan 치reas donde es razonable inferir que la gente no vive (cuerpos de agua, terrenos vac칤os). En nuestro caso, utilizamos datos GHSL y huellas de edificios como informaci칩n auxiliar para mejorar la precisi칩n de las estimaciones de distribuci칩n poblacional.",
    "crumbs": [
      "<span class='chapter-number'>1</span> <span class='chapter-title'>Exposici칩n</span>"
    ]
  },
  {
    "objectID": "exposicion.html#fuentes-de-datos",
    "href": "exposicion.html#fuentes-de-datos",
    "title": "1 Exposici칩n",
    "section": "1.3 Fuentes de datos",
    "text": "1.3 Fuentes de datos\n\n1.3.1 Censo Argentino\nLos datos censales provienen del Censo Nacional de Poblaci칩n, Hogares y Viviendas 2022 de Argentina, realizado por el Instituto Nacional de Estad칤stica y Censos (INDEC) (Instituto Nacional de Estad칤stica y Censos (INDEC) 2024). Los datos fueron descargados desde la plataforma Redatam y procesados en R en un repositorio separado, ya que result칩 m치s eficiente trabajar con esa herramienta para el procesamiento inicial. Posteriormente, estos datos fueron unidos con el conjunto de datos de radios censales de Argentina y guardados localmente. Se planea hacer disponible una copia de los datos en formato geoespacial como archivo Parquet almacenado en la nube, pero este trabajo a칰n est치 en progreso.\n\n\nMostrar c칩digo\ndatos_censales = gpd.read_parquet(\n    \"/home/nissim/Documents/dev/fulbright/ciut-redatam/datos_censales_2022_geo.parquet\"\n)\n\ndatos_censales = datos_censales.to_crs(USE_CRS)\n\ngeometria_esperanza = esperanza.geometry.iloc[0]\ncentroides_dentro = datos_censales.geometry.centroid.within(geometria_esperanza)\ncompletamente_dentro = datos_censales.within(geometria_esperanza)\ndatos_censales_esperanza = datos_censales[\n    completamente_dentro | centroides_dentro\n].copy()\n\nfig, ax = create_consistent_map(\n    \"Poblaci칩n Total por Radio Censal - Censo 2022\", esperanza\n)\n\ndatos_censales_esperanza_3857 = datos_censales_esperanza.to_crs(WEB_MERCATOR_CRS)\n\ndatos_censales_esperanza_3857.plot(\n    column=\"POB_TOT_P\", ax=ax, cmap=PLASMA_CMAP, legend=False, alpha=0.8, zorder=2\n)\n\nplt.title(\"Poblaci칩n Total por Radio Censal - Censo 2022\", fontsize=16, fontweight=\"bold\", pad=20)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n1.3.2 Datos GHSL\nLa Capa Global de Asentamientos Humanos (Global Human Settlement Layer) (Schiavina et al. 2023) es un conjunto de datos de resoluci칩n de 100 metros que proporciona estimaciones de poblaci칩n multitemporales (1975-2030) derivadas de datos censales y administrativos, informadas por la distribuci칩n y clasificaci칩n de 치reas construidas. Para este an치lisis se utilizan los datos GHSL de 2023, que son los m치s recientes disponibles y los m치s cercanos temporalmente al Censo Argentino 2022. El GHSL ya tiene un uso cient칤fico establecido para mapear la exposici칩n poblacional a peligros de inundaci칩n (Tellman et al. 2021). Sin embargo, esta fuente presenta limitaciones importantes: estudios sobre modelado de riesgo de inundaci칩n con conjuntos de datos globales han demostrado que evaluar la exposici칩n a esta escala de resoluci칩n puede llevar a sobreestimaciones de la exposici칩n poblacional en zonas de peligro de inundaci칩n en comparaci칩n con datos de mayor resoluci칩n (Smith et al. 2019).\n\n\nMostrar c칩digo\nghsl = rioxarray.open_rasterio(\n    \"/home/nissim/Documents/dev/fulbright/ciut-riesgo/notebooks/data/GHS_POP_E2025_GLOBE_R2023A_54009_100_V1_0_R13_C13/GHS_POP_E2025_GLOBE_R2023A_54009_100_V1_0_R13_C13.tif\",\n    chunks={\"x\": 1024, \"y\": 1024},\n)\n\nghsl = ghsl.rio.reproject(dst_crs=USE_CRS)\n\nghsl_clipped = ghsl.rio.clip(\n    [esperanza.geometry.iloc[0]],\n    from_disk=True,\n)\n\nghsl_masked = ghsl_clipped.where(ghsl_clipped &gt; 0)\n\nfig, ax = create_consistent_map(\n    \"Estimaciones de Poblaci칩n GHSL 2023 - Esperanza, Santa Fe\", esperanza\n)\n\nghsl_masked_3857 = ghsl_masked.rio.reproject(WEB_MERCATOR_CRS)\n\nghsl_masked_3857 = ghsl_masked_3857.where(ghsl_masked_3857 &gt; 0)\n\nghsl_masked_3857.plot(ax=ax, cmap=PLASMA_CMAP, alpha=0.75, add_colorbar=False, add_labels=False, zorder=2)\n\nplt.title(\"Estimaciones de Poblaci칩n GHSL 2023 - Esperanza, Santa Fe\", fontsize=16, fontweight=\"bold\", pad=20)\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>1</span> <span class='chapter-title'>Exposici칩n</span>"
    ]
  },
  {
    "objectID": "exposicion.html#resultados",
    "href": "exposicion.html#resultados",
    "title": "1 Exposici칩n",
    "section": "1.4 Resultados",
    "text": "1.4 Resultados\n\n\nMostrar c칩digo\ngeometrias = [geom for geom in datos_censales_esperanza.geometry]\n\nestadisticas = rasterstats.zonal_stats(\n    geometrias,\n    ghsl_clipped.values[0],\n    affine=ghsl_clipped.rio.transform(),\n    stats=[\"sum\"],\n    nodata=-200,\n)\n\ntotales_ghsl = [stat[\"sum\"] if stat[\"sum\"] is not None else 0 for stat in estadisticas]\n\ndatos_censales_esperanza[\"estimacion_pob_ghsl\"] = totales_ghsl\n\n\nraster_referencia = ghsl_clipped\ntransformacion_referencia = raster_referencia.rio.transform()\ncrs_referencia = raster_referencia.rio.crs\nforma_referencia = raster_referencia.shape[1:]\nraster_ghsl = ghsl_clipped.values[0]\n\n\ngeometrias_ghsl = [\n    (geom, valor)\n    for geom, valor in zip(\n        datos_censales_esperanza.geometry,\n        datos_censales_esperanza[\"estimacion_pob_ghsl\"],\n    )\n]\ngeometrias_pob = [\n    (geom, valor)\n    for geom, valor in zip(\n        datos_censales_esperanza.geometry, datos_censales_esperanza[\"POB_TOT_P\"]\n    )\n]\n\nraster_pob_ghsl = rasterize(\n    geometrias_ghsl,\n    out_shape=forma_referencia,\n    transform=transformacion_referencia,\n    fill=0,\n    dtype=np.float32,\n    all_touched=True,\n)\n\nraster_pob_censo = rasterize(\n    geometrias_pob,\n    out_shape=forma_referencia,\n    transform=transformacion_referencia,\n    fill=0,\n    dtype=np.float32,\n    all_touched=True,\n)\n\n\nmascara = (raster_ghsl &gt; 0) & (raster_ghsl != -200) & (raster_pob_ghsl &gt; 0.1)\nghsl_fraccional = np.full_like(raster_ghsl, 0, dtype=np.float64)\nghsl_fraccional[mascara] = raster_ghsl[mascara] / raster_pob_ghsl[mascara]\n\nmascara2 = (ghsl_fraccional &gt; 0) & (raster_pob_censo &gt; 0)\npob_redistribuida = np.full_like(raster_ghsl, 0, dtype=np.float64)\npob_redistribuida[mascara2] = ghsl_fraccional[mascara2] * raster_pob_censo[mascara2]\n\npob_redistribuida_da = xr.DataArray(\n    pob_redistribuida,\n    coords={\"y\": ghsl_clipped.y, \"x\": ghsl_clipped.x},\n    dims=[\"y\", \"x\"],\n    attrs=ghsl_clipped.attrs.copy(),\n)\n\npob_redistribuida_da = pob_redistribuida_da.rio.write_crs(USE_CRS)\n\npob_redistribuida_enmascarada = pob_redistribuida_da.where(pob_redistribuida_da &gt; 0)\n\ntotal_redistribuido = pob_redistribuida[pob_redistribuida &gt; 0].sum()\ntotal_censo = datos_censales_esperanza[\"POB_TOT_P\"].sum()\n\nfig, ax = create_consistent_map(\n    \"Poblaci칩n Redistribuida a 100m - Esperanza, Santa Fe\", esperanza\n)\n\npob_redistribuida_enmascarada_3857 = pob_redistribuida_enmascarada.rio.reproject(\n    WEB_MERCATOR_CRS\n)\n\npob_redistribuida_enmascarada_3857 = pob_redistribuida_enmascarada_3857.where(\n    pob_redistribuida_enmascarada_3857 &gt; 0\n)\n\npob_redistribuida_enmascarada_3857.plot(\n    ax=ax, cmap=PLASMA_CMAP, alpha=0.75, add_colorbar=False, add_labels=False, zorder=2\n)\n\nplt.title(\"Poblaci칩n Censal Redistribuida a 100m - Esperanza, Santa Fe\", fontsize=16, fontweight=\"bold\", pad=20)\nplt.show()\n\n\n\n\n\n\n\n\n\nEste flujo de trabajo demuestra la capacidad de redistribuir exitosamente datos de poblaci칩n censal a resoluci칩n de 100 metros utilizando datos GHSL para mapeo dasim칠trico. El proceso logra una conservaci칩n de poblaci칩n del 97.6%, redistribuyendo 45,616 personas de un total censal de 46,757 habitantes. Esta metodolog칤a permite una representaci칩n espacial m치s precisa de la distribuci칩n poblacional, manteniendo la consistencia con los datos censales oficiales.\n\n\n\n\nInstituto Nacional de Estad칤stica y Censos (INDEC). 2024. Bases de Datos. https://www.indec.gob.ar/indec/web/Institucional-Indec-BasesDeDatos-6.\n\n\nSchiavina, M., S. Freire, A. Carioli, and K. MacManus. 2023. GHS-POP R2023A - GHS Population Grid Multitemporal (1975-2030). European Commission, Joint Research Centre (JRC). https://doi.org/10.2905/2FF68A52-5B5B-4A22-8F40-C41DA8332CFE.\n\n\nSmith, A., P. D. Bates, O. Wing, et al. 2019. New Estimates of Flood Exposure in Developing Countries Using High-Resolution Population Data. Nature Communications 10: 1814. https://doi.org/10.1038/s41467-019-09282-y.\n\n\nTellman, B., J. A. Sullivan, C. Kuhn, et al. 2021. Satellite Imaging Reveals Increased Proportion of Population Exposed to Floods. Nature 596: 8086. https://doi.org/10.1038/s41586-021-03695-w.",
    "crumbs": [
      "<span class='chapter-number'>1</span> <span class='chapter-title'>Exposici칩n</span>"
    ]
  },
  {
    "objectID": "twi.html",
    "href": "twi.html",
    "title": "4 TWI y HAND",
    "section": "",
    "text": "4.1 Resumen\nEste documento eval칰a dos m칠tricas topogr치ficas simples para el mapeo de peligro de inundaci칩n: el 칈ndice de Humedad Topogr치fica (TWI) y la Altura Sobre Drenaje M치s Cercano (HAND). Utilizando el Partido de La Plata como caso de estudio, desarrollamos ambos 칤ndices mediante metodolog칤as consolidadas con datos de elevaci칩n FABDEM de acceso libre y las bibliotecas pysheds y xDEM. Los resultados se contrastan con modelado hidrol칩gico oficial disponible de la Facultad de Ingenier칤a como punto de comparaci칩n, evidenciando que tanto el TWI como el HAND representan alternativas viables para contextos con limitaciones de datos donde no existe modelado hidrol칩gico avanzado disponible. Ambos enfoques, respaldados cient칤ficamente pero con limitaciones reconocidas, constituyen soluciones pr치cticas para evaluaciones preliminares de riesgo de inundaci칩n a escala municipal cuando se carece de informaci칩n m치s detallada.",
    "crumbs": [
      "<span class='chapter-number'>4</span> <span class='chapter-title'>TWI y HAND</span>"
    ]
  },
  {
    "objectID": "twi.html#introducci칩n",
    "href": "twi.html#introducci칩n",
    "title": "4 TWI y HAND",
    "section": "4.2 Introducci칩n",
    "text": "4.2 Introducci칩n\n\n4.2.1 쯈u칠 es el TWI?\nEl TWI es un 칤ndice establecido que combina la pendiente del terreno con el 치rea de drenaje aguas arriba para identificar zonas propensas a la acumulaci칩n de agua e inundaciones. Calcula valores distribuidos espacialmente donde n칰meros m치s altos indican mayor potencial de encharcamiento y valores m치s bajos sugieren condiciones m치s secas. Es una herramienta ampliamente reconocida en hidrolog칤a para modelar condiciones de humedad del paisaje (Atlas 2025).\n\n\n4.2.2 쯈u칠 es HAND?\nHAND (Altura Sobre Drenaje M치s Cercano) es un descriptor cuantitativo del terreno que representa la diferencia de elevaci칩n entre cada pixel en la ladera y el punto m치s cercano en la red de drenaje hacia donde fluye (Johnson et al. 2019). Este m칠todo ha sido ampliamente utilizado para la predicci칩n de extensi칩n de inundaciones porque produce resultados comparables a marcos de modelado m치s complejos como HEC-RAS, pero con menores requerimientos computacionales (Johnson et al. 2019). HAND ha demostrado ser especialmente efectivo como indicador computacionalmente eficiente de susceptibilidad a inundaciones, requiriendo 칰nicamente datos topogr치ficos como entrada (Watson et al. 2024).\n\n\n4.2.3 쯇or qu칠 usar estas m칠tricas?\nTanto el TWI como HAND son m칠todos establecidos que han demostrado su validez cient칤fica en m칰ltiples aplicaciones. El TWI ha sido utilizado por agencias como el Illinois State Water Survey para identificar 치reas urbanas con riesgo de inundaci칩n (Ballerine 2017), mientras que HAND ha sido implementado por el Centro Nacional del Agua de Estados Unidos para mapeo de inundaciones a escala nacional (Johnson et al. 2019). La principal ventaja de ambas m칠tricas es que proporcionan informaci칩n valiosa sobre riesgo de inundaciones a un costo extremadamente bajo comparado con estudios hidrol칩gicos detallados. Son gratuitos, r치pidos de calcular usando datos topogr치ficos que suelen estar disponibles, y f치ciles de interpretar, convirti칠ndolos en excelentes herramientas de planificaci칩n inicial. Estudios recientes han demostrado que estas metodolog칤as pueden replicar mapas de inundaci칩n de alta resoluci칩n como indicadores de susceptibilidad a inundaciones (Watson et al. 2024; Li et al. 2023).\n\n\n4.2.4 Limitaciones\nEs fundamental entender que tanto el TWI como HAND son medidas derivadas puramente del terreno y no consideran factores como infraestructura urbana, sistemas de drenaje, vegetaci칩n, o patrones clim치ticos locales. Por tanto, son herramientas que solo proporcionan una noci칩n del riesgo relativo de inundaci칩n. No deben utilizarse para tomar decisiones a nivel de parcela espec칤fica. Para HAND espec칤ficamente, las diferencias en las caracter칤sticas del terreno y las incertidumbres asociadas con la estimaci칩n 칩ptima de par치metros pueden afectar la precisi칩n de los resultados (Thalakkottukara et al. 2024). Ambas m칠tricas se correlacionan principalmente con flujo superficial y no pueden capturar interacciones complejas con aguas subterr치neas o la din치mica completa de sistemas hidrol칩gicos urbanos.\n\n\n4.2.5 Uso apropiado\nLas investigaciones han confirmado que existe correlaci칩n entre valores altos de TWI y reportes ciudadanos de inundaciones urbanas menores, validando su utilidad en contextos urbanizados (Kelleher and McPhillips 2020). Similarmente, HAND ha demostrado ser adecuado para el mapeo de inundaciones en regiones con escasez de datos, proporcionando capacidad predictiva comparable para mapear 치reas de inundaci칩n durante eventos de lluvia extrema (Thalakkottukara et al. 2024). Ambas m칠tricas son especialmente valiosas para gobiernos municipales con recursos limitados como primera aproximaci칩n para identificar 치reas de riesgo relativo de inundaciones, desarrollar planes de emergencia y priorizar estudios m치s detallados en zonas cr칤ticas. Proporcionan un punto de partida s칩lido y cient칤ficamente respaldado para la gesti칩n del riesgo de inundaciones sin requerir inversi칩n significativa en estudios especializados.",
    "crumbs": [
      "<span class='chapter-number'>4</span> <span class='chapter-title'>TWI y HAND</span>"
    ]
  },
  {
    "objectID": "twi.html#herramientas",
    "href": "twi.html#herramientas",
    "title": "4 TWI y HAND",
    "section": "4.3 Herramientas",
    "text": "4.3 Herramientas\n\n4.3.1 PySHEDS\nPysheds es una biblioteca de Python de c칩digo abierto dise침ada por Matt Bartos para ayudar con el procesamiento de modelos digitales de elevaci칩n (DEMs), particularmente para an치lisis hidrol칩gico. Pysheds realiza muchas de las funciones hidrol칩gicas b치sicas ofrecidas por software comercial como ArcGIS, incluyendo delineaci칩n de cuencas y c치lculo de acumulaci칩n. Aqu칤, utilizamos PySheds para calcular la acumulaci칩n de flujo, que se incorpora en nuestro c치lculo del TWI.\n\n\n4.3.2 xDEM\nxDEM 랁ue creado por un grupo de investigadores con experiencia en an치lisis de datos de elevaci칩n para detecci칩n de cambios aplicado a glaciolog칤a. Hoy en d칤a, su desarrollo es liderado conjuntamente por investigadores en an치lisis de datos de elevaci칩n (incluyendo financiamiento de NASA y SNSF) e ingenieros de CNES (Agencia Espacial Francesa). Utilizamos xDEM para todo nuestro procesamiento y c치lculos de modelos digitales de elevaci칩n m치s all치 de la acumulaci칩n de flujo.\n\n\n4.3.3 FABDEM 30m\nFathom, l칤der de la industria en modelado global de inundaciones, cre칩 FABDEM espec칤ficamente para el desarrollo de sus modelos. A diferencia de otros modelos que conservan la altura de construcciones y vegetaci칩n, este utiliza t칠cnicas de inteligencia artificial para eliminar dichas interferencias y mostrar 칰nicamente la topograf칤a del suelo (Hawker et al. 2022). Su desarrollo involucr칩 datos de referencia de alta precisi칩n provenientes de doce pa칤ses con caracter칤sticas clim치ticas y urbanas diversas, lo que garantiza su aplicabilidad en distintos contextos geogr치ficos. Los datos est치n disponibles para descarga en este enlace. Para nuestros prop칩sitos, FABDEM resulta especialmente valioso dado que las investigaciones han demostrado que la calidad del modelo de elevaci칩n constituye el factor m치s influyente en la precisi칩n del modelado de riesgo de inundaciones. Al eliminar las distorsiones causadas por elementos como edificaciones y 치rboles, este modelo nos permite obtener c치lculos de TWI m치s precisos y representativos de las condiciones reales del terreno, aspecto crucial para la planificaci칩n municipal del riesgo de inundaciones.",
    "crumbs": [
      "<span class='chapter-number'>4</span> <span class='chapter-title'>TWI y HAND</span>"
    ]
  },
  {
    "objectID": "twi.html#an치lisis",
    "href": "twi.html#an치lisis",
    "title": "4 TWI y HAND",
    "section": "4.4 An치lisis",
    "text": "4.4 An치lisis\n\n4.4.1 Importar datos\nEn esta secci칩n importamos los datos de elevaci칩n FABDEM. Hemos descargado previamente los tiles necesarios para cubrir el 치rea del Partido de La Plata y los importamos usando rioxarray para crear un modelo digital de elevaci칩n fusionado que servir치 como base para nuestros c치lculos hidrol칩gicos.\n\n\nMostrar c칩digo\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\n\nfrom pathlib import Path\nimport xarray as xr\nimport rioxarray\nfrom rioxarray.merge import merge_arrays\nimport xdem\nimport tempfile\nimport numpy as np\nfrom matplotlib import colors\nimport leafmap.leafmap as leafmap\nfrom pysheds.grid import Grid\nfrom jenkspy import jenks_breaks\n\nCRS_ARGENTINA = \"EPSG:5349\"\nCRS_WGS84 = \"EPSG:4326\"\n\nRUTA_BASE = Path(\"/home/nissim/Documents/dev/fulbright/ciut-riesgo\")\nRUTA_DATOS = RUTA_BASE / \"notebooks/data\"\nRUTA_PARTIDOS = RUTA_DATOS / \"pba_partidos.geojson\"\n\nCMAP = \"BuPu\"\n\npartidos = gpd.read_file(RUTA_PARTIDOS)\npartidos = partidos.to_crs(CRS_ARGENTINA)\nla_plata = partidos[partidos[\"fna\"] == \"Partido de La Plata\"]\n\n# Quitar la isla de La Plata - mantener solo el pol칤gono m치s grande\ngeometria_principal = la_plata.geometry.iloc[0]\nif geometria_principal.geom_type == \"MultiPolygon\":\n    poligono_mayor = max(geometria_principal.geoms, key=lambda p: p.area)\n    la_plata = la_plata.copy()\n    la_plata.loc[la_plata.index[0], \"geometry\"] = poligono_mayor\n\nbbox_la_plata_4326 = la_plata.to_crs(CRS_WGS84).total_bounds\n\nrutas_tiles = [\n    RUTA_DATOS / \"fabdem/S40W060-S30W050_FABDEM_V1-2/S35W058_FABDEM_V1-2.tif\",\n    RUTA_DATOS / \"fabdem/S40W060-S30W050_FABDEM_V1-2/S36W058_FABDEM_V1-2.tif\",\n    RUTA_DATOS / \"fabdem/S40W060-S30W050_FABDEM_V1-2/S35W059_FABDEM_V1-2.tif\",\n    RUTA_DATOS / \"fabdem/S40W060-S30W050_FABDEM_V1-2/S36W059_FABDEM_V1-2.tif\",\n]\n\ntiles = [rioxarray.open_rasterio(path, chunks=True) for path in rutas_tiles]\ndem_fusionado = merge_arrays(tiles)\n\ndem_recortado = dem_fusionado.rio.clip_box(\n    minx=bbox_la_plata_4326[0],\n    miny=bbox_la_plata_4326[1],\n    maxx=bbox_la_plata_4326[2],\n    maxy=bbox_la_plata_4326[3],\n)\n\ndem_recortado.plot(cmap=CMAP)\nax = plt.gca()\nla_plata_wgs84 = la_plata.to_crs(CRS_WGS84)\nla_plata_wgs84.plot(\n    ax=ax,\n    facecolor=\"none\",\n    edgecolor=\"black\",\n    linewidth=0.5,\n    linestyle=\"--\",\n    zorder=5,\n)\n\n\n\n\n\n\n\n\n\n\n\n4.4.2 Calcular acumulaci칩n de flujo\nCalculamos la acumulaci칩n de flujo, que es esencial para el c치lculo del 칤ndice de humedad topogr치fica, siguiendo el tutorial de pysheds. No calculamos esto usando xarray porque pysheds no es compatible con xarray, pero luego convertiremos estos datos a xarray para nuestro c치lculo del TWI. El proceso incluye acondicionar el DEM eliminando pozos y depresiones, calcular direcciones de flujo, y finalmente determinar la acumulaci칩n de flujo.\n\n\nMostrar c칩digo\nwith tempfile.NamedTemporaryFile(suffix=\".tif\", delete=False) as tmp_file:\n    ruta_temporal = tmp_file.name\n\n\ndem_recortado.rio.to_raster(ruta_temporal)\ngrilla = Grid.from_raster(ruta_temporal)\n\ndem = grilla.read_raster(ruta_temporal)\n\nvalor_nodata = dem_recortado.attrs.get(\"_FillValue\", -9999.0)\n\n# Acondicionar DEM\ndem_pozos_rellenos = grilla.fill_pits(dem)\ndem_inundado = grilla.fill_depressions(dem_pozos_rellenos)\ndem_inflado = grilla.resolve_flats(dem_inundado)\n\n\ndem_inflado_xarray = xr.DataArray(\n    dem_inflado,\n    coords={\"y\": dem_recortado.y, \"x\": dem_recortado.x},\n    dims=[\"y\", \"x\"],\n    attrs=dem_recortado.attrs,\n).rio.write_crs(\"EPSG:4326\")\n\n\nmapa_direcciones = (64, 128, 1, 2, 4, 8, 16, 32)\n\n\ndirecciones_flujo = grilla.flowdir(\n    dem_inflado, dirmap=mapa_direcciones, nodata_out=np.int32(0)\n)\n\ndirecciones_flujo_xarray = xr.DataArray(\n    direcciones_flujo,\n    coords={\"y\": dem_recortado.y, \"x\": dem_recortado.x},\n    dims=[\"y\", \"x\"],\n    attrs=dem_recortado.attrs,\n).rio.write_crs(\"EPSG:4326\")\n\n\nacumulacion = grilla.accumulation(\n    direcciones_flujo, dirmap=mapa_direcciones, nodata_out=np.int32(0)\n)\n\n\nacumulacion_xarray = xr.DataArray(\n    acumulacion,\n    coords={\"y\": dem_recortado.y, \"x\": dem_recortado.x},\n    dims=[\"y\", \"x\"],\n    attrs=dem_recortado.attrs,\n).rio.write_crs(\"EPSG:4326\")\n\nfig, ax = plt.subplots(figsize=(8, 6))\nfig.patch.set_alpha(0)\nplt.grid(\"on\", zorder=0)\nim = ax.imshow(\n    acumulacion,\n    extent=grilla.extent,\n    zorder=2,\n    cmap=CMAP,\n    norm=colors.LogNorm(1, acumulacion.max()),\n    interpolation=\"bilinear\",\n)\nplt.colorbar(im, ax=ax, label=\"Celdas Aguas Arriba\")\n\nla_plata_wgs84.plot(\n    ax=ax,\n    facecolor=\"none\",\n    edgecolor=\"black\",\n    linewidth=0.5,\n    linestyle=\"--\",\n    zorder=5,\n)\nplt.title(\"Acumulaci칩n de Flujo\", size=14)\nplt.xlabel(\"Longitud\")\nplt.ylabel(\"Latitud\")\nplt.tight_layout()\n\n\n\n\n\n\n\n\n\n\n\n4.4.3 Calcular pendiente\nCalculamos la pendiente, otra variable necesaria para el c치lculo del 칤ndice de humedad topogr치fica, siguiendo el tutorial de xDEM. La pendiente es un componente fundamental de la f칩rmula del TWI y debe calcularse con precisi칩n en un sistema de coordenadas m칠tricas para obtener resultados confiables.\n\n\nMostrar c칩digo\nwith tempfile.NamedTemporaryFile(suffix=\".tif\", delete=False) as tmp_file:\n    ruta_temporal = tmp_file.name\n    \n    dem_reproyectado = dem_recortado.rio.reproject(\n        CRS_ARGENTINA,\n        resolution=30,\n    )\n    dem_reproyectado.rio.to_raster(ruta_temporal)\n    dem = xdem.DEM(ruta_temporal)\n    \n    atributos = xdem.terrain.get_terrain_attribute(\n        dem.data,\n        resolution=dem.res,\n        attribute=[\n            \"hillshade\",\n            \"slope\", \n            \"aspect\",\n            \"curvature\",\n            \"terrain_ruggedness_index\",\n            \"rugosity\",\n        ],\n    )\n    \n    datos_pendiente = atributos[1]\n    \n    # Fix coordinate generation - y should go from top to bottom\n    coordenadas_y = np.arange(dem.bounds.top, dem.bounds.bottom, -dem.res[1])\n    coordenadas_x = np.arange(dem.bounds.left, dem.bounds.right, dem.res[0])\n    \n    pendiente_xarray = xr.DataArray(\n        datos_pendiente,\n        coords={\"y\": coordenadas_y, \"x\": coordenadas_x},\n        dims=[\"y\", \"x\"],\n        attrs={\"crs\": dem.crs, \"units\": \"degrees\", \"long_name\": \"slope\"},\n    )\n\n    pendiente_xarray.plot(cmap=CMAP)\n    ax = plt.gca()\n    la_plata.plot(\n    ax=ax,\n    facecolor=\"none\",\n    edgecolor=\"black\",\n    linewidth=0.5,\n    linestyle=\"--\",\n    zorder=5,\n    )\n\n\n\n\n\n\n\n\n\n\n\n4.4.4 Calcular TWI\nCombinamos la acumulaci칩n de flujo y la pendiente para calcular el 칤ndice de humedad topogr치fica usando la f칩rmula est치ndar TWI = ln(풤 / tan()), donde 풤 es la acumulaci칩n de flujo y  es la pendiente. Ajustamos los valores extremos que surgen de dividir por pendiente cero para evitar valores infinitos en 치reas completamente planas.\n\n\nMostrar c칩digo\nacumulacion_xarray_reproyectada = acumulacion_xarray.rio.reproject(CRS_ARGENTINA)\n\n# Remuestrear pendiente para coincidir con acumulaci칩n\npendiente_remuestreada = pendiente_xarray.rio.reproject(\n    acumulacion_xarray_reproyectada.rio.crs,\n    shape=acumulacion_xarray_reproyectada.shape,\n    transform=acumulacion_xarray_reproyectada.rio.transform(),\n)\n\npendiente_rad = np.radians(pendiente_remuestreada)\ndatos_twi = np.log(acumulacion_xarray_reproyectada / np.tan(pendiente_rad))\n\n# Reemplazar valores infinitos y valores muy altos\ndatos_twi = np.where(np.isinf(datos_twi),20, datos_twi)\ndatos_twi = np.where(datos_twi &gt; 20, 20, datos_twi)\n\ntwi_xarray = xr.DataArray(\n    datos_twi,\n    coords=acumulacion_xarray_reproyectada.coords,\n    dims=acumulacion_xarray_reproyectada.dims,\n    attrs={\n        \"crs\": acumulacion_xarray_reproyectada.rio.crs,\n        \"units\": \"dimensionless\",\n        \"long_name\": \"Topographic Wetness Index\",\n        \"description\": \"ln(flow_accumulation / tan(slope + 0.0001))\",\n    },\n)\n\nplt.figure()\ntwi_xarray.plot(cmap=CMAP)\nax = plt.gca()\nla_plata.plot(\n    ax=ax,\n    facecolor=\"none\",\n    edgecolor=\"black\",\n    linewidth=0.5,\n    linestyle=\"--\",\n    zorder=5,\n)\n\n\n\n\n\n\n\n\n\n\n\nMostrar c칩digo\nhand = grilla.compute_hand(\n    direcciones_flujo, dem_inflado, acumulacion &gt; 200, nodata_value=np.int32(0)\n)\n\nhand_xarray = xr.DataArray(\n    hand,\n    coords={\"y\": dem_recortado.y, \"x\": dem_recortado.x},\n    dims=[\"y\", \"x\"],\n    attrs={\n        \"crs\": \"EPSG:4326\",\n        \"units\": \"meters\",\n        \"long_name\": \"Height Above Nearest Drainage\",\n        \"description\": \"HAND - Altura Sobre Drenaje M치s Cercano\"\n    },\n).rio.write_crs(\"EPSG:4326\")\n\nhand_xarray.plot(cmap=CMAP, figsize=(8, 6))\nax = plt.gca()\nla_plata_wgs84.plot(\n    ax=ax,\n    facecolor=\"none\",\n    edgecolor=\"black\",\n    linewidth=0.5,\n    linestyle=\"--\",\n    zorder=5,\n)\nplt.title(\"Altura Sobre Drenaje M치s Cercano (HAND)\", size=14)\nplt.tight_layout()\n\n\n\n\n\n\n\n\n\n\n\n4.4.5 An치lisis de distribuciones\nPara comprender mejor las caracter칤sticas de nuestras m칠tricas, analizamos las distribuciones de valores de TWI y HAND mediante histogramas. Esto nos permite identificar los rangos t칤picos de valores y la forma de la distribuci칩n para cada m칠trica.\n\n\nMostrar c칩digo\n# Preparar HAND con transformaci칩n de doble ra칤z cuadrada\nhand_xarray_reproyectada = hand_xarray.rio.reproject(CRS_ARGENTINA)\nhand_double_sqrt_full = np.sqrt(np.sqrt(hand_xarray_reproyectada))\nhand_double_sqrt_mask = hand_double_sqrt_full.rio.clip(la_plata.geometry, la_plata.crs, drop=False, invert=False)\nhand_double_sqrt_mask = xr.where(~hand_double_sqrt_mask.isnull(), 1, 0)\nhand_double_sqrt_masked = xr.where(hand_double_sqrt_mask == 1, hand_double_sqrt_full, np.nan)\nhand_double_sqrt_masked = hand_double_sqrt_masked.rio.write_crs(hand_double_sqrt_full.rio.crs)\nhand_double_sqrt_masked = hand_double_sqrt_masked.rio.write_transform(hand_double_sqrt_full.rio.transform())\n\n# Preparar TWI\ntwi_mask = twi_xarray.rio.clip(la_plata.geometry, la_plata.crs, drop=False, invert=False)\ntwi_mask = xr.where(~twi_mask.isnull(), 1, 0)\ntwi_masked = xr.where(twi_mask == 1, twi_xarray, np.nan)\ntwi_masked = twi_masked.rio.write_crs(twi_xarray.rio.crs)\ntwi_masked = twi_masked.rio.write_transform(twi_xarray.rio.transform())\n\n# Preparar datos v치lidos para histogramas\ntwi_values = twi_masked.values[~np.isnan(twi_masked.values)]\nhand_original = hand_xarray_reproyectada.values[~np.isnan(hand_xarray_reproyectada.values)]\nhand_double_sqrt = np.sqrt(np.sqrt(hand_original))\n\n# Calcular cortes de cuantiles\ntwi_quantiles = np.percentile(twi_values, [25, 50, 75])\nhand_double_sqrt_quantiles = np.percentile(hand_double_sqrt, [25, 50, 75])\n\n# Obtener colormap para usar los mismos colores que en los mapas\nimport matplotlib.cm as cm\ncmap = cm.get_cmap(CMAP)\ncmap_colors = [cmap(i/3) for i in range(4)]  # 4 colores del colormap\n\n# Funci칩n para asignar colores por cuantiles usando CMAP\ndef assign_quantile_colors_cmap(values, quantiles):\n    colors = []\n    for val in values:\n        if val &lt;= quantiles[0]:\n            colors.append(cmap_colors[0])  # Q1\n        elif val &lt;= quantiles[1]:\n            colors.append(cmap_colors[1])  # Q2\n        elif val &lt;= quantiles[2]:\n            colors.append(cmap_colors[2])  # Q3\n        else:\n            colors.append(cmap_colors[3])  # Q4\n    return colors\n\n# Crear figura con subplots\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))\n\n# Histograma TWI con colores por cuantiles\nn_bins = 50\ncounts1, bins1, patches1 = ax1.hist(twi_values, bins=n_bins, alpha=0.8, edgecolor='black')\nbin_centers1 = (bins1[:-1] + bins1[1:]) / 2\ncolors1 = assign_quantile_colors_cmap(bin_centers1, twi_quantiles)\nfor patch, color in zip(patches1, colors1):\n    patch.set_facecolor(color)\n\nax1.set_xlabel('Valores TWI')\nax1.set_ylabel('Frecuencia')\nax1.set_title('Distribuci칩n TWI con Cortes de Cuantiles')\nax1.grid(True, alpha=0.3)\n\n# Agregar l칤neas de cuantiles\nfor i, q in enumerate(twi_quantiles):\n    ax1.axvline(q, color='black', linestyle='--', linewidth=2, alpha=0.7)\n    ax1.text(q, ax1.get_ylim()[1]*0.9, f'Q{i+1}', rotation=90, ha='right')\n\n# Histograma HAND (double sqrt) con colores por cuantiles\ncounts2, bins2, patches2 = ax2.hist(hand_double_sqrt, bins=n_bins, alpha=0.8, edgecolor='black')\nbin_centers2 = (bins2[:-1] + bins2[1:]) / 2\ncolors2 = assign_quantile_colors_cmap(bin_centers2, hand_double_sqrt_quantiles)\nfor patch, color in zip(patches2, colors2):\n    patch.set_facecolor(color)\n\nax2.set_xlabel('Valores HAND (갴갴metros)')\nax2.set_ylabel('Frecuencia')\nax2.set_title('Distribuci칩n HAND (Doble Ra칤z Cuadrada) con Cortes de Cuantiles')\nax2.grid(True, alpha=0.3)\n\n# Agregar l칤neas de cuantiles\nfor i, q in enumerate(hand_double_sqrt_quantiles):\n    ax2.axvline(q, color='black', linestyle='--', linewidth=2, alpha=0.7)\n    ax2.text(q, ax2.get_ylim()[1]*0.9, f'Q{i+1}', rotation=90, ha='right')\n\n# Crear leyenda com칰n usando los colores del CMAP\nfrom matplotlib.patches import Patch\nlegend_elements = [\n    Patch(facecolor=cmap_colors[0], label='Q1 (0-25%)'),\n    Patch(facecolor=cmap_colors[1], label='Q2 (25-50%)'),\n    Patch(facecolor=cmap_colors[2], label='Q3 (50-75%)'),\n    Patch(facecolor=cmap_colors[3], label='Q4 (75-100%)')\n]\nfig.legend(handles=legend_elements, loc='upper center', bbox_to_anchor=(0.5, 0.95), ncol=4)\n\nplt.tight_layout()\nplt.subplots_adjust(top=0.85)\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>4</span> <span class='chapter-title'>TWI y HAND</span>"
    ]
  },
  {
    "objectID": "twi.html#comparativa-de-modelaci칩n-flo-2d-con-twi-y-hand",
    "href": "twi.html#comparativa-de-modelaci칩n-flo-2d-con-twi-y-hand",
    "title": "4 TWI y HAND",
    "section": "4.5 Comparativa de modelaci칩n FLO-2D con TWI y HAND",
    "text": "4.5 Comparativa de modelaci칩n FLO-2D con TWI y HAND\nPara validar la efectividad de estas m칠tricas topogr치ficas simples, utilizamos datos oficiales de peligro de inundaci칩n desarrollados por la Facultad de Ingenier칤a de la Universidad Nacional de La Plata como parte del Plan de Reducci칩n del Riesgo por Inundaciones en la Regi칩n de La Plata (Romanazzi et al. 2019). Estos datos de referencia fueron generados mediante la aplicaci칩n del modelo hidrol칩gico-hidr치ulico bidimensional FLO-2D, que simul칩 la din치mica de inundaci칩n de todas las cuencas del partido de La Plata para distintos escenarios de eventos pluviom칠tricos extremos. La disponibilidad de este modelado detallado proporciona una oportunidad 칰nica para evaluar qu칠 tan bien corresponden estos 칤ndices topogr치ficos simples con el modelado hidr치ulico m치s completo como prueba de concepto.\nPara la comparaci칩n, presentamos el TWI en su forma continua, permitiendo visualizar la variaci칩n completa de valores de humedad topogr치fica. Para HAND, aplicamos cortes de cuantiles con cuatro clases que dividen el 치rea de estudio en zonas de igual extensi칩n (25% cada una), facilitando la identificaci칩n de gradientes de riesgo relativo de inundaci칩n. Esta aproximaci칩n permite una comparaci칩n visual clara entre los diferentes enfoques metodol칩gicos.\nUn aspecto importante a considerar es que existen diferencias metodol칩gicas fundamentales entre estos enfoques. El modelado de ingenier칤a toma en cuenta la infraestructura urbana, especialmente el sistema de calles de la ciudad y elementos del drenaje urbano, mientras que tanto el TWI como HAND se basan 칰nicamente en la topograf칤a del terreno.\n\nMostrar c칩digo\n# Preparar datos para el mapa\nruta_peligro = RUTA_DATOS / \"peligro_raster_10m.tif\"\npeligro_xarray = rioxarray.open_rasterio(ruta_peligro)\n\n# Crear clases de quantiles para TWI usando los breaks calculados\ntwi_quantile_classes = xr.where(twi_masked &lt;= twi_quantiles[0], 1,\n                               xr.where(twi_masked &lt;= twi_quantiles[1], 2,\n                                       xr.where(twi_masked &lt;= twi_quantiles[2], 3, 4)))\ntwi_quantile_classes = xr.where(~twi_masked.isnull(), twi_quantile_classes, np.nan)\ntwi_quantile_classes = twi_quantile_classes.rio.write_crs(twi_masked.rio.crs)\ntwi_quantile_classes = twi_quantile_classes.rio.write_transform(twi_masked.rio.transform())\n\n# Crear clases de quantiles para HAND usando los breaks calculados\nhand_quantile_classes = xr.where(hand_double_sqrt_masked &lt;= hand_double_sqrt_quantiles[0], 1,\n                                xr.where(hand_double_sqrt_masked &lt;= hand_double_sqrt_quantiles[1], 2,\n                                        xr.where(hand_double_sqrt_masked &lt;= hand_double_sqrt_quantiles[2], 3, 4)))\nhand_quantile_classes = xr.where(~hand_double_sqrt_masked.isnull(), hand_quantile_classes, np.nan)\nhand_quantile_classes = hand_quantile_classes.rio.write_crs(hand_double_sqrt_masked.rio.crs)\nhand_quantile_classes = hand_quantile_classes.rio.write_transform(hand_double_sqrt_masked.rio.transform())\n\n# Preparar datos de peligrosidad\npeligro_2d = peligro_xarray.sel(band=1).astype('float32')\npeligro_clipped = peligro_2d.rio.clip(la_plata.geometry, la_plata.crs)\n\n# Definir funci칩n para crear mapas consistentes\ndef create_consistent_map(title, boundary_gdf, bounds=None):\n    \"\"\"Create a map with consistent styling and basemap.\"\"\"\n    fig, ax = plt.subplots(figsize=(8, 6))\n    \n    if bounds is not None:\n        ax.set_xlim(bounds[0], bounds[2])\n        ax.set_ylim(bounds[1], bounds[3])\n    \n    if boundary_gdf is not None:\n        boundary_gdf.plot(\n            ax=ax,\n            facecolor=\"none\",\n            edgecolor=\"black\",\n            linewidth=0.5,\n            linestyle=\"--\",\n            zorder=5,\n        )\n    \n    ax.set_title(title, fontsize=14, fontweight=\"bold\", pad=20)\n    ax.set_axis_off()\n    \n    return fig, ax\n\n# Obtener bounds comunes para todos los mapas\ncommon_bounds = la_plata.to_crs(CRS_ARGENTINA).total_bounds\n\n# Mapa 1: TWI\nfig1, ax1 = create_consistent_map(\"칈ndice de Humedad Topogr치fica (TWI)\", boundary_gdf=la_plata, bounds=common_bounds)\n\ntwi_masked_3857 = twi_masked.rio.reproject(\"EPSG:3857\")\ntwi_masked_3857.plot(ax=ax1, cmap=CMAP, add_colorbar=True, cbar_kwargs={\"label\": \"칈ndice de Humedad Topogr치fica\"})\n\nplt.tight_layout()\nplt.show()\n\n# Mapa 2: HAND\nfig2, ax2 = create_consistent_map(\"Altura Sobre Drenaje M치s Cercano (HAND)\", boundary_gdf=la_plata, bounds=common_bounds)\n\nhand_quantile_classes_3857 = hand_quantile_classes.rio.reproject(\"EPSG:3857\")\nhand_quantile_classes_3857.plot(\n    ax=ax2,\n    cmap=CMAP + \"_r\",\n    add_colorbar=True,\n    cbar_kwargs={\n        \"label\": \"HAND (Cuantiles)\",\n        \"ticks\": [1.5, 2.5, 3.5, 4.5],\n        \"format\": lambda x, pos: f\"Q{int(x)}\"\n    }\n)\n\nplt.tight_layout()\nplt.show()\n\n# Mapa 3: Peligrosidad FLO-2D\nfig3, ax3 = create_consistent_map(\"Modelado FLO-2D (Peligrosidad)\", boundary_gdf=la_plata, bounds=common_bounds)\n\npeligro_clipped_3857 = peligro_clipped.rio.reproject(\"EPSG:3857\")\npeligro_clipped_3857.plot(\n    ax=ax3,\n    cmap=CMAP,\n    add_colorbar=True,\n    cbar_kwargs={\"label\": \"Nivel de Peligrosidad\"}\n)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n(a) 칈ndice de Humedad Topogr치fica (TWI)\n\n\n\n\n\n\n\n\n\n\n\n(b) Altura Sobre Drenaje M치s Cercano (HAND)\n\n\n\n\n\n\n\n\n\n\n\n(c) Modelado FLO-2D (Peligrosidad)\n\n\n\n\n\n\n\nFigure4.1: Comparativa de TWI, HAND y modelado FLO-2D",
    "crumbs": [
      "<span class='chapter-number'>4</span> <span class='chapter-title'>TWI y HAND</span>"
    ]
  },
  {
    "objectID": "twi.html#conclusi칩n",
    "href": "twi.html#conclusi칩n",
    "title": "4 TWI y HAND",
    "section": "4.6 Conclusi칩n",
    "text": "4.6 Conclusi칩n\nNuestro an치lisis demuestra que tanto el TWI como HAND corresponden bien al modelado hidrol칩gico desarrollado por la Facultad de Ingenier칤a H칤drica de la Universidad Nacional de La Plata. A pesar de las diferencias metodol칩gicas entre estos enfoques, la correspondencia espacial general es s칩lida, proporcionando confianza en el uso de ambas m칠tricas como herramientas de evaluaci칩n preliminar para el riesgo de inundaciones. Tanto el TWI como HAND constituyen herramientas valiosas y cient칤ficamente respaldadas para evaluaciones preliminares de riesgo de inundaci칩n a escala municipal, especialmente en contextos con limitaciones de datos donde no existe modelado hidrol칩gico avanzado disponible. Los resultados son consistentes con estudios internacionales que han validado estas metodolog칤as en ciudades como Katmand칰, Nepal (Watson et al. 2024; Li et al. 2023) y en regiones rurales de Estados Unidos (Thalakkottukara et al. 2024), lo que nos proporciona confianza para usar estos datos en evaluaciones iniciales de peligro de inundaci칩n.\n\n\n\n\nAtlas. 2025. Topographic Wetness IndexGIS Use Cases. https://atlas.co/gis-use-cases/topographic-wetness-index/.\n\n\nBallerine, C. 2017. Topographic Wetness Index Urban Flooding Awareness Act Action Support. Technical report; University of Illinois at Urbana-Champaign, Prairie Research Institute.\n\n\nHawker, L., P. Uhe, L. Paulo, J. Sosa, J. Savage, C. Sampson, and J. Neal. 2022. ㄹ 30 m Global Map of Elevation with Forests and Buildings Removed. Environmental Research Letters 17 (2): 024016. https://doi.org/10.1088/1748-9326/ac4d4f.\n\n\nJohnson, J. M., D. Munasinghe, D. Eyelade, and S. Cohen. 2019. ㄹn Integrated Evaluation of the National Water Model (NWM)뉻eight Above Nearest Drainage (HAND) Flood Mapping Methodology. Natural Hazards and Earth System Sciences 19 (11): 240520. https://doi.org/10.5194/nhess-19-2405-2019.\n\n\nKelleher, C., and L. McPhillips. 2020. Exploring the Application of Topographic Indices in Urban Areas as Indicators of Pluvial Flooding Locations. Hydrological Processes 34 (3): 78094. https://doi.org/10.1002/hyp.13628.\n\n\nLi, Z., F. Q. Duque, T. Grout, B. Bates, and I. Demir. 2023. Comparative Analysis of Performance and Mechanisms of Flood Inundation Map Generation Using Height Above Nearest Drainage. Environmental Modelling & Software 159: 105565. https://doi.org/10.1016/j.envsoft.2022.105565.\n\n\nRomanazzi, Pablo et al. 2019. Plan de Reducci칩n Del Riesgo Por Inundaciones En La Regi칩n de La Plata. Edited by Sebasti치n Guerrini, Pablo Morosi, Eduardo Pablo Spinelli, and Josefina L칩pez MacKenzie. 1st ed. La Plata: Universidad Nacional de La Plata. Facultad de Ingenier칤a; Municipalidad de La Plata. https://sedici.unlp.edu.ar/bitstream/handle/10915/165109/Documento_completo.pdf-PDFA.pdf?sequence=1&isAllowed=y.\n\n\nThalakkottukara, N. T., J. Thomas, M. K. Watkins, et al. 2024. Suitability of the Height Above Nearest Drainage (HAND) Model for Flood Inundation Mapping in Data-Scarce Regions: A Comparative Analysis with Hydrodynamic Models. Earth Science Informatics 17: 190721. https://doi.org/10.1007/s12145-023-01218-x.\n\n\nWatson, C. S., J. Gyawali, M. Creed, and J. R. Elliott. 2024. City-Scale High-Resolution Flood Models and the Role of Topographic Data: A Case Study of Kathmandu, Nepal. Geocarto International 39 (1): 2387073. https://doi.org/10.1080/10106049.2024.2387073.",
    "crumbs": [
      "<span class='chapter-number'>4</span> <span class='chapter-title'>TWI y HAND</span>"
    ]
  },
  {
    "objectID": "edificaciones.html",
    "href": "edificaciones.html",
    "title": "1 Edificaciones",
    "section": "",
    "text": "Mostrar c칩digo\nimport matplotlib.pyplot as plt\n\nfrom shapely.geometry import box\nimport geopandas as gpd\nimport os\n\n\nfrom matplotlib_map_utils import north_arrow, scale_bar\n\n\nimport contextily as cx\n\n\nimport pandas as pd\nimport contextily as ctx\n\n\nimport boto3\nimport duckdb\nimport s2sphere\nfrom botocore.config import Config\n\n\nfrom io import BytesIO\nfrom owslib.wfs import WebFeatureService\n\n\nUSE_CRS = \"EPSG:5349\"  # POSGAR 2007 / Argentina 4\nWEB_MERCATOR_CRS = \"EPSG:3857\"  # visualizaci칩n\nWGS84_CRS = \"EPSG:4326\"  # para llamadas API\n\nBASE_RUTA = \"/home/nissim/Documents/dev/fulbright/ciut-riesgo\"\nDATA_RUTA = f\"{BASE_RUTA}/notebooks/data\"\nPARTIDOS_RUTA = f\"{DATA_RUTA}/pba_partidos.geojson\"\nEDIFICACIONES_RUTA = f\"{BASE_RUTA}/notebooks/edificaciones_filtered.parquet\"\n\nPARTIDOS_WFS_URL = \"https://geo.arba.gov.ar/geoserver/idera/wfs\"\n\n\n\n\nMostrar c칩digo\nif os.path.exists(PARTIDOS_RUTA):\n    print(\"Cargando datos de partidos existentes...\")\n    partidos = gpd.read_file(PARTIDOS_RUTA)\nelse:\n    print(\"Descargando datos de partidos desde servicio WFS...\")\n\n    # Conectar al servicio WFS\n    wfs = WebFeatureService(url=PARTIDOS_WFS_URL, version=\"2.0.0\")\n\n    # Descargar la capa de departamentos\n    response = wfs.getfeature(typename=\"idera:Departamento\", srsname=\"EPSG:5347\")\n\n    # Convertir a GeoDataFrame\n    partidos = gpd.read_file(BytesIO(response.read()))\n\n    # Guardar para uso futuro\n    partidos.to_file(PARTIDOS_RUTA, driver=\"GeoJSON\")\n    print(f\"Descargados {len(partidos)} partidos\")\n\npartidos = partidos.to_crs(USE_CRS)\naoi = partidos[partidos[\"fna\"] == \"Partido de La Plata\"]\n\n# Obtener la geometr칤a principal\nmain_geom = aoi.geometry.iloc[0]\n\n# Si es un MultiPolygon, mantener solo el pol칤gono m치s grande (el partido principal)\n# Esto elimina la peque침a isla que aparece en los datos\nif main_geom.geom_type == \"MultiPolygon\":\n    # Obtener todos los pol칤gonos y mantener el que tenga mayor 치rea\n    largest_polygon = max(main_geom.geoms, key=lambda p: p.area)\n    aoi = aoi.copy()  # Crear una copia para evitar SettingWithCopyWarning\n    aoi.loc[aoi.index[0], \"geometry\"] = largest_polygon\n\naoi_bbox = aoi.geometry.iloc[0]\n\nif os.path.exists(EDIFICACIONES_RUTA):\n    print(\"Cargando datos de edificaciones existentes...\")\n    edificaciones = gpd.read_parquet(EDIFICACIONES_RUTA)\nelse:\n    print(\"Obteniendo datos de edificaciones del dataset VIDA...\")\n\n    # Paso 1: Obtener el punto central de La Plata en coordenadas WGS84\n    aoi_buffered = aoi.buffer(500)  # Agregar buffer de 500m para obtener datos\n    center = aoi_buffered.to_crs(WEB_MERCATOR_CRS).union_all().centroid\n    center_wgs84 = (\n        gpd.GeoDataFrame(geometry=[center], crs=WEB_MERCATOR_CRS)\n        .to_crs(WGS84_CRS)\n        .geometry.iloc[0]\n    )\n    print(f\"Coordenadas del centro: {center_wgs84.y:.4f}, {center_wgs84.x:.4f}\")\n\n    # Paso 2: Encontrar la celda S2 apropiada para particionamiento espacial\n    cell = s2sphere.CellId.from_lat_lng(\n        s2sphere.LatLng.from_degrees(center_wgs84.y, center_wgs84.x)\n    ).parent(10)\n    print(f\"ID de celda S2: {cell.id()}\")\n\n    # Paso 3: Obtener bounding box en WGS84 para filtrado espacial\n    bounds = aoi_buffered.to_crs(WGS84_CRS).total_bounds\n    print(f\"Caja delimitadora: {bounds}\")\n\n    # Paso 4: Conectar a S3 y encontrar particiones disponibles\n    s3 = boto3.client(\n        \"s3\",\n        endpoint_url=\"https://data.source.coop\",\n        aws_access_key_id=\"\",\n        aws_secret_access_key=\"\",\n        config=Config(s3={\"addressing_style\": \"path\"}),\n    )\n\n    # Obtener lista de particiones S2 disponibles\n    partitions = {\n        obj[\"Key\"].split(\"/\")[-1].replace(\".parquet\", \"\")\n        for obj in s3.list_objects_v2(\n            Bucket=\"vida\",\n            Prefix=\"google-microsoft-osm-open-buildings/geoparquet/by_country_s2/country_iso=ARG/\",\n        ).get(\"Contents\", [])\n    }\n    print(f\"Encontradas {len(partitions)} particiones disponibles\")\n\n    # Paso 5: Encontrar la partici칩n padre apropiada\n    parent_id = next(\n        str(cell.parent(level).id())\n        for level in range(10, 0, -1)\n        if str(cell.parent(level).id()) in partitions\n    )\n    print(f\"Usando partici칩n: {parent_id}\")\n\n    # Paso 6: Configurar DuckDB para consultas espaciales\n    con = duckdb.connect()\n    print(\"Configurando DuckDB con extensiones espaciales...\")\n    for cmd in [\n        \"INSTALL spatial\",\n        \"LOAD spatial\",\n        \"INSTALL httpfs\",\n        \"LOAD httpfs\",\n        \"SET s3_region='us-east-1'\",\n        \"SET s3_endpoint='data.source.coop'\",\n        \"SET s3_use_ssl=true\",\n        \"SET s3_url_style='path'\",\n    ]:\n        con.execute(cmd)\n\n    # Paso 7: Consultar y filtrar edificaciones dentro de nuestra 치rea de inter칠s\n    print(\"Consultando edificaciones dentro del 치rea de La Plata...\")\n    query = f\"\"\"\n    COPY (SELECT * FROM 's3://vida/google-microsoft-osm-open-buildings/geoparquet/by_country_s2/country_iso=ARG/{parent_id}.parquet'\n          WHERE bbox.xmax &gt;= {bounds[0]} AND bbox.xmin &lt;= {bounds[2]} AND\n                bbox.ymax &gt;= {bounds[1]} AND bbox.ymin &lt;= {bounds[3]}\n    ) TO '{EDIFICACIONES_RUTA}' (FORMAT PARQUET);\n    \"\"\"\n\n    con.execute(query)\n\n    # Paso 8: Cargar los datos filtrados y convertir a GeoDataFrame\n    df = pd.read_parquet(EDIFICACIONES_RUTA)\n    df[\"geometry\"] = gpd.GeoSeries.from_wkb(df[\"geometry\"])\n    edificaciones = gpd.GeoDataFrame(df, geometry=\"geometry\", crs=WGS84_CRS)\n\n    print(f\"Obtenidas {len(edificaciones)} edificaciones\")\n    con.close()\n\n\n# Filtrar edificaciones para incluir solo las que est치n dentro de los l칤mites de La Plata\nedificaciones_proj = edificaciones.to_crs(USE_CRS)\nedificaciones_proj = edificaciones_proj[\n    edificaciones_proj.geometry.intersects(aoi_bbox)\n]\n\n\nCargando datos de partidos existentes...\nCargando datos de edificaciones existentes...\n\n\n\n\nMostrar c칩digo\n# Obtener l칤mites de La Plata y convertir a Web Mercator para visualizaci칩n\naoi_bounds = aoi_bbox.bounds\ntemp_bounds = gpd.GeoDataFrame(\n    geometry=[box(aoi_bounds[0], aoi_bounds[1], aoi_bounds[2], aoi_bounds[3])],\n    crs=USE_CRS,\n)\nbounds_3857 = temp_bounds.to_crs(WEB_MERCATOR_CRS).total_bounds\n\nfig, ax = plt.subplots(figsize=(12, 10))\nax.set_xlim(bounds_3857[0] - 500, bounds_3857[2] + 500)\nax.set_ylim(bounds_3857[1] - 500, bounds_3857[3] + 500)\n\ncx.add_basemap(\n    ax,\n    crs=WEB_MERCATOR_CRS,\n    source=ctx.providers.CartoDB.PositronNoLabels,\n    attribution=\"Datos: VIDA (2023), IGN (2025) | Mapa base: Carto (2025)\",\n)\n\nscale_bar(\n    ax=ax,\n    location=\"upper left\",\n    style=\"ticks\",\n    bar={\n        \"projection\": \"EPSG:3857\",\n        \"tickcolors\": \"black\",\n        \"basecolors\": \"black\",\n        \"minor_type\": \"none\",\n        \"length\": 0.20,\n    },\n    labels={\"style\": \"first_last\"},\n)\n\n# Add north arrow\nnorth_arrow(\n    ax,\n    location=\"upper right\",\n    scale=0.3,\n    rotation={\"degrees\": 0},\n    base={\"facecolor\": \"none\", \"edgecolor\": \"black\", \"linewidth\": 1},\n    fancy=True,\n    shadow=True,\n    label=False,\n)\n\naoi_3857 = aoi.to_crs(WEB_MERCATOR_CRS)\naoi_3857.plot(\n    ax=ax,\n    facecolor=\"none\",\n    edgecolor=\"black\",\n    linewidth=0.5,\n    linestyle=\"--\",\n    legend=False,\n    zorder=5,\n)\n\nedificaciones_3857 = edificaciones_proj.to_crs(WEB_MERCATOR_CRS)\nedificaciones_3857.plot(ax=ax, facecolor=\"grey\", edgecolor=\"none\", alpha=0.7)\n\nax.set_title(\"Huellas de edificios\", fontsize=16, fontweight=\"bold\", pad=20)\nax.set_axis_off()\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nFigure1.1: Huellas de edificios en La Plata, PBA",
    "crumbs": [
      "<span class='chapter-number'>1</span> <span class='chapter-title'>Edificaciones</span>"
    ]
  },
  {
    "objectID": "renabap.html#footnotes",
    "href": "renabap.html#footnotes",
    "title": "4 RENABAP",
    "section": "",
    "text": "Los barrios que forman parte, son aquellos 띿enominados villas, asentamientos y urbanizaciones informales que presentan diferentes grados de precariedad. Deben ser un m칤nimo de ocho familias agrupadas o contiguas en donde m치s de la mitad de sus habitantes no cuenten con t칤tulo de propiedad del suelo ni acceso formal de dos servicios b치sicos (luz, agua, cloaca).뢕뾆잹",
    "crumbs": [
      "<span class='chapter-number'>4</span> <span class='chapter-title'>RENABAP</span>"
    ]
  }
]